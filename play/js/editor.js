// Generated by CoffeeScript 2.3.0
(function() {
  var makes, petals, subtypes, zooms;

  zooms = [300, 800, 1200];

  petals = [[+1, 0], [+2, -1], [+1, -2], [0, -1]];

  makes = ['Entity', 'Block', 'Surface', 'Light', 'Decal', 'Activator', 'Parking space', 'Safe Zone', 'Walk', 'Drive', 'Door', 'Neon'];

  subtypes = ['scrub1', 'Table', 'Desk', 'Chair', 'Couch', 'Dumpster', 'Generator', 'ATM'];

  gg.Editor = class Editor {
    constructor() {
      var blue, geom, i, j, len, p, petal, that;
      console.log('~`~`~`~`~`~ New Editor mate');
      that = this;
      this.insect = null;
      this.face = 0;
      this.boot = null;
      this.ant = null;
      this.mark = null;
      this.links = [];
      this.linking = 'Walk';
      this.incline = 1;
      this.make = 'Block';
      this.mode = 'Select';
      this.zoom = 0;
      this.petals = [];
      blue = new THREE.MeshBasicMaterial({
        color: 0x0000cc,
        opacity: .3,
        transparent: true
      });
      geom = new THREE.PlaneGeometry(64, 64, 1);
      i = 0;
      for (j = 0, len = petals.length; j < len; j++) {
        p = petals[j];
        petal = new THREE.Mesh(geom, blue);
        petal.petal = true;
        petal.name = `petal ${i++}`;
        petal.ggsolid = {
          props: {
            type: 'Petal'
          }
        };
        petal.position.set(p[0] * 64, p[1] * 64, 64 + 1);
        this.petals.push(petal);
      }
      this.flower = false;
      this.bucket = false;
      this.brush = true;
      this.over = false;
      this.build();
      $.getJSON('play/stys.json', function(data) {
        that.stys = data;
        that.stys['~none~'] = 'spoof';
        return that.cats();
      });
      gg.ed = this;
    }

    // gg.map.dtor()
    build() {
      var a, cats, ed, fluke, j, k, len, len1, select, stys, withselected;
      ed = $('<div id="ed">');
      cats = $('<div id="cats">');
      stys = $('<div id="stys">');
      fluke = 'href="javascript:;"';
      ed.append($(`<a ${fluke}>export</a>`).click(function() {
        return gg.ed.export();
      }));
      ed.append(', ');
      ed.append($(`<a id="brush" ${fluke}>brush: on</a>`).click(function() {
        gg.ed.brush = !gg.ed.brush;
        $(this).html(`brush: ${(gg.ed.brush ? 'on' : 'off')}`);
      }));
      ed.append(', ');
      ed.append($(`<a ${fluke}>flower: off</a>`).click(function() {
        var index, j, len, petal, ref;
        gg.ed.flower = !gg.ed.flower;
        $(this).html(`flower: ${(gg.ed.flower ? 'on' : 'off')}`);
        if (!gg.ed.flower) {
          ref = gg.ed.petals;
          for (j = 0, len = ref.length; j < len; j++) {
            petal = ref[j];
            gg.scene.remove(petal);
            index = gg.map.meshes.indexOf(petal);
            if (-1 !== index) {
              gg.map.meshes.splice(index, 1);
            }
          }
        }
      }));
      ed.append(', ');
      ed.append($(`<a id="mode" ${fluke}>mode: ${this.mode}</a>`).click(function() {
        if (gg.ed.mode === 'Make') {
          gg.ed.mode = 'Select';
        } else {
          gg.ed.mode = 'Make';
        }
        $(this).html(`mode: ${gg.ed.mode}`);
      }));
      ed.append(', ');
      ed.append($(`<a id="bucket" ${fluke}>bucket: off</a>`).click(function() {
        gg.ed.bucket = !gg.ed.bucket;
        $(this).html(`bucket: ${(gg.ed.bucket ? 'on' : 'off')}`);
      }));
      ed.append(', ');
      ed.append($(`<a id="bucket" ${fluke}>zoom: ${zooms[this.zoom]}</a>`).click(function() {
        gg.ed.zoom = gg.ed.zoom === 2 ? 0 : gg.ed.zoom + 1;
        $(this).html(`zoom: ${zooms[gg.ed.zoom]}`);
        gg.zoom = zooms[gg.ed.zoom];
      }));
      ed.append(', ');
      select = $('<select id="makes">');
      for (j = 0, len = makes.length; j < len; j++) {
        a = makes[j];
        select.append(`<option>${a}`);
      }
      ed.append(select.click(() => {
        this.make = $('#makes option:selected').text();
      }));
      select = $('<select id="subtypes">');
      for (k = 0, len1 = subtypes.length; k < len1; k++) {
        a = subtypes[k];
        select.append(`<option>${a}`);
      }
      ed.append(select.click(() => {
        this.subtype = $('#subtypes option:selected').text();
      }));
      // ed.append ', '
      $('#links').remove();
      ed.append('<div>props of selected: <div id="props">nothng selected</div></div>');
      withselected = $('<div class>with selected: </div>');
      withselected.append($(`<a  ${fluke}>move (sticky)</a>`).click(() => {
        var ref, ref1, ref2;
        if ((ref = this.mark) != null ? ref.object.ggsolid : void 0) {
          this.sticky = (ref1 = this.mark) != null ? ref1.object.ggsolid : void 0;
          gg.bubble(`Stickying ${((ref2 = this.mark) != null ? ref2.object.ggsolid.type : void 0)}`);
        }
        return 1;
      }));
      withselected.append(', ');
      withselected.append($(`<a ${fluke}>delete</a>`).click(() => {
        var ref;
        return this.deletev((ref = this.mark) != null ? ref.object.ggsolid : void 0);
      }));
      withselected.append(', ');
      withselected.append($(`<a ${fluke}>> change vjson <</a>`).click(() => {
        var r, v;
        if (this.mark == null) {
          return;
        }
        v = this.mark.object.ggsolid;
        r = prompt('Change vjson', v.props.vjson);
        if (r == null) {
          return;
        }
        v.vjson = JSON.parse(r);
        v.props.vjson = r;
        if (v.vjson == null) {
          return;
        }
        if (typeof v.reload === "function") {
          v.reload();
        }
        return 42;
      }));
      withselected.append(', ');
      withselected.append($(`<a ${fluke}>incline: ${this.incline}</a>`).click(function() {
        if (1 === gg.ed.incline) {
          gg.ed.incline = -1;
        } else if (-1 === gg.ed.incline) {
          gg.ed.incline = .5;
        } else if (.5 === gg.ed.incline) {
          gg.ed.incline = -.5;
        } else if (-.5 === gg.ed.incline) {
          gg.ed.incline = 1;
        }
        $(this).html(`incline: ${gg.ed.incline}th`);
        return 42;
      }));
      withselected.append(', ');
      withselected.append($(`<a ${fluke}>raise</a>`).click(() => {
        var ref, v;
        v = (ref = this.mark) != null ? ref.object.ggsolid : void 0;
        v.props.z += 1;
        return v.pose();
      }));
      withselected.append(', ');
      withselected.append($(`<a ${fluke}>lower</a>`).click(() => {
        var ref, v;
        v = (ref = this.mark) != null ? ref.object.ggsolid : void 0;
        v.props.z -= 1;
        return v.pose();
      }));
      withselected.append(', slope: ');
      withselected.append($(`<a ${fluke}>n</a>`).click(() => {
        return this.slopev(this.mark, 0);
      }));
      withselected.append(',');
      withselected.append($(`<a ${fluke}>e</a>`).click(() => {
        return this.slopev(this.mark, 1);
      }));
      withselected.append(',');
      withselected.append($(`<a ${fluke}>s</a>`).click(() => {
        return this.slopev(this.mark, 2);
      }));
      withselected.append(',');
      withselected.append($(`<a ${fluke}>w</a>`).click(() => {
        return this.slopev(this.mark, 3);
      }));
      withselected.append(', wedge: ');
      withselected.append($(`<a ${fluke}>ne</a>`).click(() => {
        return this.wedgev(this.mark, 0);
      }));
      withselected.append(',');
      withselected.append($(`<a ${fluke}>se</a>`).click(() => {
        return this.wedgev(this.mark, 1);
      }));
      withselected.append(',');
      withselected.append($(`<a ${fluke}>sw</a>`).click(() => {
        return this.wedgev(this.mark, 2);
      }));
      withselected.append(',');
      withselected.append($(`<a ${fluke}>nw</a>`).click(() => {
        return this.wedgev(this.mark, 3);
      }));
      withselected.append(', rotate 12th: ');
      withselected.append($(`<a ${fluke}>cw</a>`).click(() => {
        var ref, v;
        v = (ref = this.mark) != null ? ref.object.ggsolid : void 0;
        v.props.r -= Math.PI / 12;
        return v.pose();
      }));
      withselected.append(' - ');
      withselected.append($(`<a ${fluke}>ccw</a>`).click(() => {
        var ref, v;
        v = (ref = this.mark) != null ? ref.object.ggsolid : void 0;
        v.props.r += Math.PI / 12;
        return v.pose();
      }));
      // withselected.append ', '
      ed.append(withselected);
      ed.append(cats);
      $('#overlay').append(ed);
      cats.append(stys);
      cats.append('palette: ');
      ed.mouseenter(() => {
        return this.over = true;
      });
      ed.mouseleave(() => {
        return this.over = false;
      });
      return 1;
    }

    deletev(v) {
      var a;
      this.unmark();
      a = gg.map.nosj.visuals;
      a.splice(a.indexOf(v.props), 1);
      a = gg.map.meshes;
      a.splice(a.indexOf(v.mesh), 1);
      v.chunk.removev(v);
      gg.bubble(`Deleted the selected ${v.type}`);
      return 0;
    }

    slopev(mark, d) {
      var base, v;
      v = mark != null ? mark.object.ggsolid : void 0;
      if (!(v && (v.type === 'Block' || v.type === 'Surface'))) {
        return;
      }
      if ((base = v.props).s == null) {
        base.s = [0, 0, 0, 0];
      }
      v.props.s[d] += this.incline;
      v.slope();
      gg.bubble(`Sloped your ${v.type} to ${v.props.s[d]}`);
      return 0;
    }

    wedgev(mark, d) {
      var base, v;
      v = mark != null ? mark.object.ggsolid : void 0;
      if (!(v && v.type === 'Block')) {
        return;
      }
      if ((base = v.props).w == null) {
        base.w = [
          false,
          false,
          false,
          false // i will never forget
        ];
      }
      v.props.w[d] = !v.props.w[d];
      v.wedge();
      gg.bubble(`Wedged your ${v.type}`);
      return 1;
    }

    update() {
      return 1;
    }

    key() {
      var j, k, l, len, len1, len2, len3, m, minus, other, plus, ref, ref1, ref2, ref3, ref4, shift, v, w;
      shift = gg.keys[16];
      minus = 1 === gg.keys[189];
      plus = 1 === gg.keys[187];
      v = (ref = this.insect) != null ? ref.object.ggsolid : void 0;
      if ((minus || plus) && v) {
        gg.bubble(`Raising or lowering ${v.type} by .1`);
        if (minus) {
          v.props.z -= 8 / 64 * Math.abs(this.incline);
        } else {
          v.props.z += 8 / 64 * Math.abs(this.incline);
        }
        v.pose();
      } else if (1 === gg.keys[27]) {
        if (this.mark != null) {
          this.unmark();
        }
        this.sticky = null;
        ref1 = this.links;
        for (j = 0, len = ref1.length; j < len; j++) {
          w = ref1[j];
          this.color({
            object: {
              ggsolid: w
            }
          }, w.constructor.color);
        }
        this.links = [];
      } else if (1 === gg.keys[82]) {
        if (v == null) {
          return;
        }
        v.props.r = 3 === v.props.r ? 0 : v.props.r + 1;
        gg.bubble(`Rotate to ${v.props.r}`);
        switch (v.type) {
          case 'Block':
            gg.rotateplane(v.geometry, 4, 1);
            break;
          case 'Surface':
            gg.rotateplane(v.geometry, 0, 1);
        }
      } else if (1 === gg.keys[70]) {
        if (v == null) {
          return;
        }
        v.props.f = !v.props.f;
        gg.bubble(`Flip to ${v.props.f}`);
        switch (v.type) {
          case 'Block':
            gg.flipplane(v.geometry, 4, 1);
            break;
          case 'Surface':
            gg.flipplane(v.geometry, 0, 1);
        }
      } else if (gg.keys[32]) {
        
        // type = @linking is 'walks'
        gg.bubble(`Linking all marked ${this.linking} nodes (${this.links.length})...`);
        ref2 = this.links;
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          w = ref2[k];
          ref3 = this.links;
          for (l = 0, len2 = ref3.length; l < len2; l++) {
            other = ref3[l];
            if (w === other) {
              continue;
            }
            if (!!!~w.vjson.links.indexOf(other.vjson.id)) {
              gg.bubble('Linked');
              w.vjson.links.push(other.vjson.id);
            }
          }
          w.props.vjson = JSON.stringify(w.vjson);
        }
        console.log(`Unmarking all marked ${this.linking}...`);
        ref4 = this.links;
        for (m = 0, len3 = ref4.length; m < len3; m++) {
          w = ref4[m];
          this.color({
            object: {
              ggsolid: w
            }
          }, w.constructor.color);
        }
        this.links = [];
      }
      return 1;
    }

    cat(a) {
      var folder, img, imgs, j, len, lol, ref, stys;
      stys = $('#stys');
      stys.html('');
      gg.ed.sty = null;
      if ('~none~' === a) {
        return;
      }
      ref = this.stys[a];
      for (folder in ref) {
        imgs = ref[folder];
        stys.append(`<br/>${folder}<br/>`);
        for (j = 0, len = imgs.length; j < len; j++) {
          img = imgs[j];
          lol = $(`<img src="play/sty/${a}/${folder}/${img}" />`);
          lol.data('path', `${a}/${folder}/${img}`);
          lol.click(function() {
            var ref1, that;
            that = $(this);
            that.addClass('mark');
            if ((ref1 = gg.ed.sty) != null) {
              ref1.removeClass('mark');
            }
            return gg.ed.sty = that;
          });
          stys.append(lol);
        }
      }
      return 0;
    }

    cats() {
      var a, cat, nyan;
      nyan = $('#cats');
      for (a in this.stys) {
        console.log(a);
        cat = $(`<a href="javascript:;" class="cat">${a}</a>`);
        cat.data('cat', a);
        cat.click(function() {
          return gg.ed.cat($(this).data('cat'));
        });
        nyan.append(cat);
      }
      return 1;
    }

    mousing() {
      var ant, boot, center, ch, change, clash, i, index, insect, insects, j, k, l, len, len1, len2, petal, pos, props, ref, ref1, ref2, ref3, ref4, ref5, shift, v, w, want, y;
      if (this.over) {
        return;
      }
      insects = gg.raycaster.intersectObjects(gg.map.meshes);
      change = true; // no
      if (insects.length) {
        boot = insects[0];
        ant = insects[1];
        shift = gg.keys[16];
        // return if @insect? and insect.object is @insect.object
        insect = shift && (ant != null) ? ant : boot;
        change = ((ref = this.insect) != null ? ref.object.ggsolid : void 0) !== (insect != null ? insect.object.ggsolid : void 0) || this.insect.faceIndex !== insect.faceIndex;
        if (this.insect != null) {
          // return unless change
          this.color(this.insect, (ref1 = this.insect) != null ? (ref2 = ref1.object.ggsolid) != null ? ref2.constructor.color : void 0 : void 0);
        }
        // purple
        if ((function() {
          var j, len, ref3, ref4, results;
          ref3 = this.links;
          results = [];
          for (j = 0, len = ref3.length; j < len; j++) {
            w = ref3[j];
            results.push(w === ((ref4 = this.insect) != null ? ref4.object.ggsolid : void 0));
          }
          return results;
        }).call(this)) {
          this.color({
            object: {
              ggsolid: w
            }
          }, 0xc000ff);
        }
        this.color(insect, 0x880000);
        if (this.mark != null) {
          this.color(this.mark, 0xffffff);
        }
        this.insect = insect;
        this.face = insect.faceIndex;
      }
      if (change && !insect.object.petal) {
        center = insect.object.ggsolid;
        y = 0;
        if (insect.faceIndex === 8 || insect.faceIndex === 9) {
          y = 1;
        }
        switch (center.type) {
          case 'Light':
          case 'Walk':
          case 'Drive':
          case 'Parking space':
          case 'Safe Zone':
          case 'Decal':
            return;
        }
        i = -1;
        ref3 = this.petals;
        for (j = 0, len = ref3.length; j < len; j++) {
          petal = ref3[j];
          i++;
          clash = false || !this.flower;
          want = {
            x: center.props.x + petals[i][0] - 1,
            y: center.props.y + petals[i][1] + 1,
            z: center.props.z + y
          };
          ref4 = gg.map.actives;
          // `CAT: //`
          for (k = 0, len1 = ref4.length; k < len1; k++) {
            ch = ref4[k];
            if (clash) {
              break;
            }
            ref5 = ch.visuals;
            for (l = 0, len2 = ref5.length; l < len2; l++) {
              v = ref5[l];
              if (!(v.type === 'Block' || v.type === 'Surface')) {
                continue;
              }
              pos = {
                x: v.props.x,
                y: v.props.y,
                z: v.props.z
              };
              if (want.x === pos.x && want.y === pos.y && want.z === pos.z) {
                clash = true;
                gg.scene.remove(petal);
                index = gg.map.meshes.indexOf(petal); 
                if (!!~index) {
                  gg.map.meshes.splice(index, 1);
                }
                break;
              }
            }
          }
          if (clash) {
            // `break CAT`
            continue;
          }
          if (!gg.scene.getObjectByName(`petal ${i}`)) {
            gg.scene.add(petal);
            gg.map.meshes.push(petal);
          }
          props = petal.ggsolid.props;
          props.x = want.x;
          props.y = want.y;
          props.z = want.z;
          petal.position.set(want.x * 64 + 32, want.y * 64 + 32, want.z * 64);
        }
      }
      return 1;
    }

    color(insect, hex) {
      var i, ref, v;
      v = insect.object.ggsolid;
      if (v == null) {
        return;
      }
      if (hex == null) {
        hex = gg.outside;
      }
      switch (v.type) {
        case 'Surface':
        case 'Decal':
        case 'Activator':
        case 'Sprite':
        case 'Entity':
        case 'Light':
        case 'Walk':
        case 'Drive':
        case 'Parking space':
        case 'Safe Zone':
          v.mesh.material.color.setHex(hex);
          break;
        case 'Block':
          i = gg.C.faces[insect.faceIndex];
          if ((ref = v.mesh) != null) {
            ref.material[i].color.setHex(hex);
          }
      }
      return 1;
    }

    click() {
      var c, cx, cxy, cy, f, grid, grit, gritty, i, j, k, l, len, len1, len2, len3, len4, m, n, node, o, obj, other, p, petal, pool, pos, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, t, v, w;
      if (this.over) {
        return;
      }
      petal = (ref = this.insect) != null ? ref.object.petal : void 0;
      v = (ref1 = this.insect) != null ? ref1.object.ggsolid : void 0;
      if (1 === gg.left && (this.sticky != null)) {
        p = {
          x: this.insect.point.x,
          y: this.insect.point.y,
          z: this.insect.point.z
        };
        this.sticky.props.x = p.x;
        this.sticky.props.y = p.y;
        this.sticky.props.z = p.z;
        this.sticky.pose();
        this.sticky = null;
        gg.bubble(`Repositioned your ${this.sticky.type}`);
      } else if (1 === gg.right && (v != null) && !petal && (v.type === 'Walk' || v.type === 'Drive')) {
        if (this.linking !== v.type && this.links.length) {
          gg.bubble(`You\'re linking a different type. Press esc to link ${v.type} nodes instead of ${this.linking} nodes.`);
          return;
        } else if (this.linking !== v.type) {
          this.linking = v.type;
        }
        this.links.push(v);
        this.color(this.insect, 0x880000);
        gg.bubble(`Selected ${this.linking}: (${this.links.length}). Press esc to unselect all nodes.`);
      } else if (1 === gg.left && gg.keys[88] && (v != null)) {
        if (petal) {
          return;
        }
        this.deletev(v);
        if ('Walk' === v.type || 'Drive' === v.type) {
          gg.bubble(`Smartly deleting a ${v.type} node`);
          ref2 = v.vjson.links;
          for (j = 0, len = ref2.length; j < len; j++) {
            i = ref2[j];
            if ('Walk' === v.type) {
              node = gg.walks[i];
            }
            if ('Drive' === v.type) {
              node = gg.drives[i];
            }
            pos = node.vjson.links.indexOf(v.vjson.id);
            node.vjson.links.splice(pos, 1);
            node.props.vjson = JSON.stringify(node.vjson);
          }
        }
      } else if (1 === gg.left && (v != null) && this.mode === 'Select') {
        if (petal) {
          gg.bubble('Hint: Can\'t select blue tiles. If you want to build, change the mode.');
          return;
        }
        if (this.mark != null) {
          this.unmark();
        }
        gg.bubble(`Selected ${v.type}`);
        $('#props').html(JSON.stringify(v.props));
        this.color(this.insect, 0xffffff);
        this.mark = this.insect;
        if ('Walk' === v.type || 'Drive' === v.type) {
          gg.bubble('Hint: Use rightclick to select multiple nodes.');
        }
      } else if (1 === gg.right) {
        this.paint();
      } else if (1 === gg.left && (v != null) && this.mode === 'Make') {
        n = {};
        if (this.mark != null) {
          gg.bubble("Adopting props from mark");
          n = JSON.parse(JSON.stringify(this.mark.object.ggsolid.props));
        }
        t = ((ref3 = this.sty) != null ? ref3.data('path') : void 0) || 'special/null/null.bmp';
        n.type = this.make;
        p = {
          x: this.insect.point.x,
          y: this.insect.point.y,
          z: this.insect.point.z
        };
        grit = {
          x: this.insect.object.ggsolid.props.x,
          y: this.insect.object.ggsolid.props.y,
          z: this.insect.object.ggsolid.props.z
        };
        gritty = petal || v.type === 'Surface' || v.type === 'Block';
        n.x = p.x;
        n.y = p.y;
        n.z = p.z;
        if ('Block' === v.type) {
          switch (this.insect.faceIndex) {
            case 0:
            case 1:
              grit.x += 1;
              break;
            case 2:
            case 3:
              grit.x -= 1;
              break;
            case 4:
            case 5:
              grit.y += 1;
              break;
            case 6:
            case 7:
              grit.y -= 1;
              break;
            case 8:
            case 9:
              grit.z += 1;
          }
        }
        if (gg.interior) {
          n.interior = gg.interior.name;
        }
        grid = false;
        if (!gritty && (this.make === 'Block' || this.make === 'Surface')) {
          gg.bubble('Not a proper place to put this');
          return;
        }
        if (this.make === 'Block') { // or @make is 'Wall'
          ref4 = gg.C.faceNames;
          for (k = 0, len1 = ref4.length; k < len1; k++) {
            f = ref4[k];
            if (n[f] == null) {
              n[f] = t;
            }
          }
          grid = true;
        } else if (this.make === 'Surface') {
          if (n.sty == null) {
            n.sty = t;
          }
          grid = true;
        } else if (this.make === 'Decal') {
          n.decal = this.subtype;
          n.r = (Math.PI * 2) * Math.random();
        } else if ('Tree' === this.make) {
          n.r = (Math.PI * 2) * Math.random();
        } else if ('Activator' === this.make) {
          n.type = this.subtype;
        } else if ('Pickup' === this.make) {
          // n.state = {type: this.activator};
          n.type = this.pickup;
        // n.vjson = '{"id":'+ gg.entitypool +',"type":"Vendor"}';
        } else if ('Drive' === this.make || 'Walk' === this.make) {
          if ('Walk' === this.make) {
            pool = ++gg.walkpool;
          }
          if ('Drive' === this.make) {
            pool = ++gg.drivepool;
          }
          // grid = true if 'Drive' is @make
          obj = {
            id: pool,
            type: 'normal',
            links: []
          };
          if (this.links.length < 1) {
            console.log("no links selected, making unlinked walk");
          } else if (this.make === this.linking) {
            console.log('unlinking marks to interpolate with a new one');
            ref5 = this.links;
            for (l = 0, len2 = ref5.length; l < len2; l++) {
              w = ref5[l];
              obj.links.push(w.vjson.id);
              w.vjson.links.push(obj.id);
              ref6 = this.links;
              for (m = 0, len3 = ref6.length; m < len3; m++) {
                other = ref6[m];
                if (w === other) {
                  continue;
                }
                pos = w.vjson.links.indexOf(other.vjson.id);
                if (pos !== -1) {
                  console.log('Adding unlinked marked node');
                  w.vjson.links.splice(pos, 1);
                }
              }
              w.props.vjson = JSON.stringify(w.vjson);
            }
          }
          n.vjson = JSON.stringify(obj);
          console.log('Placed a node. Unmarking all marked links.');
          ref7 = this.links;
          for (o = 0, len4 = ref7.length; o < len4; o++) {
            w = ref7[o];
            this.color({
              object: {
                ggsolid: w
              }
            }, 0xc000ff);
          }
          this.links = [];
        } else if ('Parking space' === this.make) {
          gg.parkingspacepool++;
          n.vjson = '{"id":' + gg.parkingspacepool + ',"type":"spawn"}';
        } else if ('Safe Zone' === this.make) {
          gg.entitypool++;
          n.vjson = '{"id":' + gg.entitypool + ',"faction":"Default"}';
        } else if ('Entity' === this.make) {
          gg.entitypool++;
          n.vjson = '{"id":' + gg.entitypool + ',"type":"Vendor"}';
        }
        cx = 0;
        cy = 0;
        if (!grid) {
          cx = Math.floor((n.x / 64) / gg.C.CHUNKSPAN);
          cy = Math.floor((n.y / 64) / gg.C.CHUNKSPAN);
        } else {
          n.x = grit.x;
          n.y = grit.y;
          n.z = grit.z;
          cx = Math.floor(n.x / gg.C.CHUNKSPAN);
          cy = Math.floor(n.y / gg.C.CHUNKSPAN);
        }
        cxy = cx + ',' + cy;
        c = gg.map.offChunks[cxy] || (gg.map.offChunks[cxy] = new gg.Chunk(cx, cy));
        v = null;
        v = c.addr(n);
        gg.map.nosj.visuals.push(n);
        if (v.mesh) {
          gg.map.meshes.push(v.mesh);
        }
        gg.map.cyancubes();
        console.log('you placed a visual cg');
        console.log(n);
      }
      return 1;
    }

    paint() {
      var i, sty, visual;
      if (!(this.brush && (this.insect != null) && (this.sty != null))) {
        return;
      }
      visual = this.insect.object.ggsolid;
      if (visual == null) {
        return;
      }
      sty = this.sty.data('path');
      switch (visual.type) {
        case 'Block':
          i = gg.C.faces[this.insect.faceIndex];
          visual.mesh.material[i].map = gg.loadSty(sty);
          visual.props[gg.C.faceNames[i]] = sty;
          break;
        case 'Surface':
          visual.mesh.material.map = gg.loadSty(sty);
          visual.props.sty = sty;
      }
      return 1;
    }

    unmark() {
      var ref;
      if (this.mark != null) {
        this.color(this.mark, (ref = this.mark.object.ggsolid) != null ? ref.constructor.color : void 0);
      }
      this.mark = null;
      $('#props').html('nothing selected');
      return 1;
    }

    optimize(raws) {
      var allzero, f, i, j, k, l, len, len1, len2, props, ref, ref1;
      if (raws == null) {
        raws = gg.map.nosj.visuals.slice(0);
      }
      for (j = 0, len = raws.length; j < len; j++) {
        props = raws[j];
        // delete v.temporal
        delete props.hide;
        if (props.type === 'Block') {
          ref = gg.C.faceNames;
          for (i = k = 0, len1 = ref.length; k < len1; i = ++k) {
            f = ref[i];
            if (props[f] === 'special/null/null.bmp') {
              console.log('deleting null surface');
              delete props[f];
            }
          }
        }
        if (props.s) {
          allzero = true;
          ref1 = props.s;
          for (l = 0, len2 = ref1.length; l < len2; l++) {
            i = ref1[l];
            if (i) {
              allzero = false;
              break;
            }
          }
          if (allzero) {
            delete props.s;
          }
        }
      }
      return 1;
    }

    export() {
      var field, form, raws, str;
      raws = gg.map.nosj.visuals.slice(0);
      this.optimize(raws);
      str = JSON.stringify(raws);
      form = $('<form id="poster" method="post" action="php/writenosj.php" style="display:none">');
      field = $('<input type="hidden" name="served">');
      field.attr('value', str);
      form.append(field);
      $('body').append(form);
      form.submit();
      return 1;
    }

  };

}).call(this);
