// Generated by CoffeeScript 2.3.0
(function() {
  var neons, rotations;

  rotations = [[0, 1], [1, 0], [0, -1], [-1, 0]];

  neons = {
    'Gunstore A': {
      sty: 'gunstore',
      depth: 32,
      width: 256,
      height: 32
    },
    'Centre Hotel': {
      sty: 'centre hotel',
      depth: 28,
      width: 256,
      height: 32
    }
  };

  gg.Neon = class Neon extends gg.Visual {
    constructor(props) {
      super(props);
      this.type = 'Neon';
      this.model = neons[this.vjson.neon];
      gg.neon = this; // debug
      this.width = this.vjson.width || 64;
      this.height = this.vjson.height || 3;
      this.depth = this.vjson.depth || 16;
      this.timer = 0;
      this.pixel = 0;
      if ((gg.interior != null) && gg.interior.name === this.vjson.hiddenfor) {
        return;
      }
      this.shape();
      if (this.model != null) {
        this.board();
      }
      this.pose();
    }

    build() {
      if (this.mesh != null) {
        gg.scene.add(this.mesh);
      }
      if (this.boardmesh != null) {
        gg.scene.add(this.boardmesh);
      }
      return true;
    }

    dtor() {
      if (this.mesh != null) {
        gg.scene.remove(this.mesh);
      }
      if (this.boardmesh != null) {
        gg.scene.remove(this.boardmesh);
      }
      return true;
    }

    step() {
      var x, y;
      if (!((this.mesh != null) && (this.model != null))) {
        return;
      }
      this.timer += gg.delta;
      if (this.timer > .07) {
        this.timer = 0;
        this.pixel += 1;
        if (this.pixel > this.model.width) {
          this.pixel -= this.model.width;
        }
      }
      x = this.pixel / this.model.width;
      y = (1 - (this.depth / this.model.height)) / 2;
      return gg.posplane(this.geometry, 0, x, y, this.width / this.model.width, this.depth / this.model.height);
    }

    pose() {
      var r1, r2;
      r1 = rotations[this.props.r][0];
      r2 = rotations[this.props.r][1];
      this.mesh.position.x = (this.props.x * 64) + 32 + r1 * (64 - this.height) / 2;
      this.mesh.position.y = (this.props.y * 64) + 32 + r2 * (64 - this.height) / 2;
      this.mesh.position.z = (this.props.z * 64) + (64 - this.depth) / 2 + this.depth / 2;
      this.mesh.rotation.z = -(Math.PI / 2) * this.props.r;
      if (this.boardmesh == null) {
        return;
      }
      this.boardmesh.position.x = (this.props.x * 64) + 32 - (r1 * this.height / 2) + r1 * (64 - this.height) / 2;
      this.boardmesh.position.y = (this.props.y * 64) + 32 - (r2 * this.height / 2) + r2 * (64 - this.height) / 2;
      this.boardmesh.position.z = (this.props.z * 64) + (64 - this.depth) / 2 + this.depth / 2;
      this.boardmesh.rotation.x = Math.PI / 2;
      this.boardmesh.rotation.y = -(Math.PI / 2) * this.props.r;
      return true;
    }

    shape() {
      var f, i, j, len, materials, ref;
      materials = [];
      ref = gg.C.faceNames;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        f = ref[i];
        materials[i] = gg.material('metal/conveyor/310.bmp');
      }
      materials[3].map = gg.loadSty('misc/a/neonpixels.bmp');
      materials[3].specularMap = materials[3].map;
      materials[3].specular = new THREE.Color(0xffffff);
      materials[3].map.wrapT = THREE.RepeatWrapping;
      materials[3].map.wrapS = THREE.RepeatWrapping;
      this.material = materials;
      this.geometry = new THREE.BoxBufferGeometry(this.width, this.height, this.depth);
      gg.posplane(this.geometry, 4, 0, .5, this.width / 64, this.height / 64);
      gg.posplane(this.geometry, 0, 0, .5, this.height / 64, this.depth / 64);
      gg.posplane(this.geometry, 1, 0, .5, this.height / 64, this.depth / 64);
      gg.posplane(this.geometry, 2, 0, .5, this.width / 64, this.depth / 64);
      gg.posplane(this.geometry, 3, 0, .5, this.width / 64, this.depth / 64);
      gg.rotateplane(this.geometry, 0, 3);
      gg.rotateplane(this.geometry, 1, 1);
      gg.rotateplane(this.geometry, 2, 2);
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.ggsolid = this; // arb prop
      return 1;
    }

    board() {
      var board, map;
      map = gg.loadSty(`nontile/neons/${this.model.sty}.png`);
      map.wrapT = THREE.RepeatWrapping;
      map.wrapS = THREE.RepeatWrapping;
      board = gg.material(`nontile/neons/${this.model.sty}.png`);
      this.geometry = new THREE.PlaneBufferGeometry(this.width, this.depth, 1);
      this.boardmesh = new THREE.Mesh(this.geometry, board);
      return 1;
    }

  };

}).call(this);
