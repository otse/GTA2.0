// Generated by CoffeeScript 2.3.0
(function() {
  gg.Chunk = class Chunk {
    constructor(x, y) {
      this.id = gg.CHUNKID++;
      this.x = x;
      this.y = y;
      this.hash = `${x},${y}`;
      this.tiles = [];
      /*	bunch of json strings, mostly from nosj.json */
      this.raws = [];
      /* these are gg.Visual objects factoried from @raws */
      this.visuals = [];
      this.lights = [];
      this.group = new THREE.Group;
      this.group.matrixAutoUpdate = false;
      this.prefab = false;
    }

    // unused
    post() {
      console.log('Ch post');
      // @gays = @visuals.filter (v) -> 'Surface' is v.type or 'Block' is v.type
      return 0;
    }

    _preppl(r) {
      var l;
      l = gg.visualFactory(r);
      l.chunk = this;
      l.build(false);
      this.lights.push(l);
      return l;
    }

    addr(r) {
      var v;
      this.raws.push(r);
      if ('Light' === r.type) {
        this._preppl(r);
        return;
      }
      if (this.active) {
        if (r.hide) {
          return;
        }
        v = gg.visualFactory(r);
        v.chunk = this;
        v.build(false);
        if (v.mesh != null) {
          this.group.add(v.mesh);
        }
        this.visuals.push(v);
        return v;
      }
      return null;
    }

    removev(v) {
      this.raws.splice(this.raws.indexOf(v.raw), 1);
      if (this.active) {
        this.visuals.splice(this.visuals.indexOf(v), 1);
        this.group.remove(v.mesh);
        v.dtor();
      }
      return 1;
    }

    disappear(deep = false) {
      var i, j, l, len, len1, ref, ref1, v;
      gg.scene.remove(this.group);
      if (deep) {
        console.log('deep del ch');
        ref = this.visuals;
        for (i = 0, len = ref.length; i < len; i++) {
          v = ref[i];
          v.dtor();
        }
        this.visuals = [];
        this.tiles = [];
        this.group.children.length = 0;
        this.prefab = false;
      }
      this.active = false;
      ref1 = this.lights;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        l = ref1[j];
        gg.lightmanager.checkoff(l.light);
      }
      return 1;
    }

    show(pre = false) {
      var i, j, l, len, len1, r, ref, ref1, v;
      if (!pre) {
        this.active = true;
      }
      if (!this.prefab) {
        ref = this.raws;
        for (i = 0, len = ref.length; i < len; i++) {
          r = ref[i];
          if (r.hide) {
            continue;
          }
          if (r.interior && ((gg.interior == null) || r.interior !== gg.interior.name)) {
            continue;
          }
          v = gg.visualFactory(r);
          v.chunk = this;
          v.build(false);
          if (v.mesh != null) {
            this.group.add(v.mesh); // and not v.props.hide
          }
          this.visuals.push(v);
        }
        this.prefab = true;
      }
      if (!pre) {
        gg.scene.add(this.group);
      }
      if (!pre) {
        ref1 = this.lights;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          l = ref1[j];
          gg.lightmanager.register(l.light);
        }
      }
      // console.log "this chgroup has #{@group.children.length} meshes"
      return 1;
    }

  };

}).call(this);
