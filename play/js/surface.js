// Generated by CoffeeScript 2.3.0
(function() {
  gg.Surface = class Surface extends gg.Visual {
    // @color: 0xffffff
    constructor(props) {
      var z;
      super(props);
      this.type = 'Surface';
      if (props.r == null) {
        props.r = 0;
      }
      if (props.f == null) {
        props.f = 0;
      }
      z = props.z * 64;
      this.raise = {
        z: z,
        tl: z,
        tr: z,
        bl: z,
        br: z,
        mean: z
      };
      this.tile = `${Math.floor(this.props.x)},${Math.floor(this.props.y)}`;
    }

    dtor() {
      var ref;
      if ((ref = this.chunk) != null) {
        delete ref.tiles[this.tile];
      }
      super.dtor();
      return 1;
    }

    build(solo) {
      var base, name;
      this.shape();
      this.pose();
      if ((base = this.chunk.tiles)[name = this.tile] == null) {
        base[name] = [];
      }
      this.chunk.tiles[this.tile].push(this);
      super.build(solo);
      return 1;
    }

    pose() {
      this.mesh.position.set((this.props.x * 64) + 32, (this.props.y * 64) + 32, this.props.z * 64);
      this.mesh.updateMatrix();
      this.mesh.updateMatrixWorld();
      return 1;
    }

    slope() {
      var i, incline, p, ref, s;
      if (this.props.s == null) {
        return;
      }
      ref = this.props.s;
      for (i in ref) {
        incline = ref[i];
        if (!incline) { // ! 0
          continue;
        }
        p = this.geometry.attributes.position.array;
        this.geometry.attributes.position.needsUpdate = true;
        s = 8 * incline;
        switch (parseInt(i)) { // ! important
          case 0: // n
            this.raise.tr = this.raise.z + s;
            this.raise.tl = this.raise.z + s;
            p[2] = s;
            p[5] = s;
            break;
          case 1: // e
            this.raise.tr = this.raise.z + s;
            this.raise.br = this.raise.z + s;
            p[5] = s;
            p[11] = s;
            break;
          case 2: // s
            this.raise.bl = this.raise.z + s;
            this.raise.br = this.raise.z + s;
            p[8] = s;
            p[11] = s;
            break;
          case 3: // w
            this.raise.tl = this.raise.z + s;
            this.raise.bl = this.raise.z + s;
            p[2] = s;
            p[8] = s;
        }
      }
      this.raise.mean = (this.raise.tl + this.raise.tr + this.raise.bl + this.raise.br) / 4;
      return 1;
    }

    shape() {
      var salt;
      if ("special/water/1.bmp" === this.props.sty) {
        this.material = gg.water;
      } else {
        salt = this.props.s != null ? 'Sloped' : '';
        this.material = gg.material(this.props.sty, this, salt, false);
      }
      this.geometry = new THREE.PlaneBufferGeometry(64, 64, 1, 1);
      if (this.props.f) {
        gg.flipplane(this.geometry, 0, true);
      }
      if (this.props.r) {
        gg.rotateplane(this.geometry, 0, this.props.r);
      }
      this.slope();
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.castShadow = false;
      this.mesh.receiveShadow = true;
      // @mesh.frustumCulled = false
      this.mesh.matrixAutoUpdate = false;
      this.mesh.ggsolid = this; // arb prop
      return 1;
    }

  };

}).call(this);
