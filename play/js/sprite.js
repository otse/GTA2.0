// Generated by CoffeeScript 2.3.0
(function() {
  // by default a sprite works outside of chunks
  gg.Sprite = (function() {
    class Sprite extends gg.Visual {
      constructor(props, sprite) {
        super(props);
        this.sprite = sprite;
        this.type = 'Sprite';
        this.sty = gg.loadSty(this.sprite.path);
        if (this.sprite.scale == null) {
          this.sprite.scale = 1;
        }
        // @understeer = true
        this.keyframe = [1, 3, 3, 7];
        gg.Sprite.prototype.patch.call(this, props);
        this.last = gg.delta;
        this.tile = ':o';
        this.on = null;
        // @autonomous = yes
        this.pixie();
      }

      dtor() {
        gg.scene.remove(this.mesh);
        if (this.shadow != null) {
          gg.scene.remove(this.shadow);
        }
        this.shadow = null;
        super.dtor();
        return 12;
      }

      state(o) {
        this.props.states = o;
        return 1;
      }

      build(solo) {
        super.build(solo);
        if (this.shadow != null) {
          gg.scene.add(this.shadow);
        }
        return 1;
      }

      pixie() {
        var asd;
        this.material = gg.material(this.sprite.path, this, this.sprite.salt);
        this.geometry = new THREE.PlaneBufferGeometry(this.sprite.sprite.width * this.sprite.scale, this.sprite.sprite.height * this.sprite.scale, 1);
        this.geometry.addAttribute('uv2', new THREE.BufferAttribute(this.geometry.attributes.uv.array, 2)); // for shadow light/ao maps
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.castShadow = false;
        this.mesh.receiveShadow = false;
        
        // @mesh.frustumCulled = false
        this.mesh.ggsolid = this;
        if (!this.sprite.hasShadow) {
          return;
        }
        asd = new THREE.MeshBasicMaterial({
          map: this.sty,
          color: 0x000000,
          opacity: .25,
          transparent: true
        });
        this.shadow = new THREE.Mesh(this.geometry, asd);
        return 1;
      }

      pose() {
        this.mesh.position.set(this.props.x, this.props.y, this.props.z + this.sprite.elevation);
        this.mesh.rotation.z = this.props.r;
        if (!(this.sprite.hasShadow && (this.shadow != null))) {
          return;
        }
        this.shadow.position.set(this.props.x + 3, this.props.y + -3, this.props.z + 1); // @props.z + @sprite.elevation - 1
        this.shadow.rotation.z = this.props.r;
        return 1;
      }

      frame(i, y, geometry) {
        var ex, h, w, x;
        ex = (this.sprite.x / this.sprite.sheet.width) || 0;
        x = ex + (1 / (this.sprite.sheet.width / this.sprite.sprite.width)) * i;
        y = y;
        w = 1 / (this.sprite.sheet.width / this.sprite.sprite.width);
        h = this.sprite.sprite.height / this.sprite.sheet.height;
        gg.posplane(geometry || this.geometry, 0, x, y, w, h);
        return [x, y, w, h];
      }

      patch(o) {
        var d;
        if ((o.r != null) && this.understeer) {
          // return unless @props.net
          o.r = gg.normalize(o.r);
        }
        if (o.x != null) {
          this.keyframe[0] = o.x;
        }
        if (o.y != null) {
          this.keyframe[1] = o.y;
        }
        if (o.r != null) {
          this.keyframe[2] = o.r;
        }
        // @keyframe[3] = o.z if o.z?
        this.curs = [this.props.x, this.props.y, this.props.r, this.props.z];
        if ((o.r != null) && this.understeer) {
          d = o.r - this.props.r;
          if (d < -Math.PI) {
            this.curs[2] = -(d + gg.C.PII);
          } else if (d > Math.PI) {
            this.curs[2] = gg.C.PII + gg.C.PII - d;
          }
        }
        this.last = 0;
        return 1;
      }

      tween() {
        var i, j;
        this.adds = [0, 0, 0, 0];
        for (i = j = 0; j <= 3; i = ++j) {
          this.adds[i] = (this.keyframe[i] - this.curs[i]) * .1;
        }
        this.props.x += this.adds[0];
        this.props.y += this.adds[1];
        this.props.r += this.adds[2];
        // @props.z += @adds[3]
        if (this.understeer) {
          if (this.props.r > gg.C.PII) {
            this.props.r = this.props.r - gg.C.PII;
          } else if (this.props.r < 0) {
            this.props.r = gg.C.PII - this.props.r;
          }
        }
        return true;
      }

      step() {
        // return if @props.isPart? # sprites with base dont step
        this.zaware();
        this.raise();
        if (!this.props.net) {
          return;
        }
        this.last += gg.delta;
        if (this.last > 0.1) {
          this.patch({
            x: this.keyframe[0],
            y: this.keyframe[1],
            r: this.keyframe[2],
            z: this.keyframe[3]
          });
        }
        this.tween();
        return 1;
      }

      zaware() {
        var c, j, len, ref, tile, tiles, v, xy;
        tile = `${Math.floor(this.props.x / 64)},${Math.floor(this.props.y / 64)}`;
        if (tile === this.tile) {
          return;
        }
        this.tile = tile;
        xy = `${Math.floor(this.props.x / gg.C.CHUNITS)},${Math.floor(this.props.y / gg.C.CHUNITS)}`;
        this.at = gg.map.offChunks[xy];
        if (!((ref = this.at) != null ? ref.active : void 0)) {
          return;
        }
        tiles = this.at.tiles[this.tile];
        if (!((tiles != null) && Array.isArray(tiles))) {
          return;
        }
        c = tiles[0];
        for (j = 0, len = tiles.length; j < len; j++) {
          v = tiles[j];
          if (Math.abs(this.props.z - v.raise.mean) < Math.abs(this.props.z - c.raise.mean)) {
            c = v;
          }
        }
        this.on = c;
        return 0;
      }

      raise() {
        var hit, ref, ref1;
        if (this.on == null) {
          return;
        }
        if (this.on.props.s == null) { // simple surface
          this.props.z = this.on.raise.mean;
          return;
        }
        gg.Sprite.prototype.raycaster.ray.origin.copy(new THREE.Vector3(this.props.x, this.props.y, this.props.z + 5));
        hit = gg.Sprite.prototype.raycaster.intersectObject(this.on.mesh);
        this.props.z = ((ref = hit[0]) != null ? (ref1 = ref.point) != null ? ref1.z : void 0 : void 0) + 1 || this.on.raise.mean;
        return 1;
      }

    };

    Sprite.prototype.raycaster = new THREE.Raycaster(new THREE.Vector3, new THREE.Vector3(0, 0, -1));

    return Sprite;

  }).call(this);

  gg.SpriteClone = class SpriteClone extends gg.Visual {
    constructor(props, sprite, parent = null) {
      super(props);
      this.sprite = sprite;
      this.parent = parent;
      if (this.parent == null) {
        console.warn('Bad Parenting');
      }
      this.type = 'Sprite Clone';
      this.fairy();
    }

    dtor() {
      gg.scene.remove(this.mesh);
      super.dtor();
      return 1;
    }

    fairy() {
      this.material = gg.material(this.sprite.path, this, this.sprite.salt);
      this.mesh = new THREE.Mesh(this.parent.geometry, this.material);
      // @mesh.ggsolid = this
      return 1;
    }

    pose() {
      this.mesh.position.set(this.parent.props.x, this.parent.props.y, this.parent.props.z + this.parent.sprite.elevation);
      this.mesh.rotation.z = this.parent.props.r;
      return 1;
    }

    step() {
      return 1;
    }

  };

}).call(this);
