// Generated by CoffeeScript 2.3.0
(function() {
  gg.Activator = (function() {
    class Activator extends gg.Sprite {
      constructor(props) {
        var anim, model, sprite;
        if (props.id == null) {
          // console.log "new activator at #{props.x} #{props.y} #{props.z}"
          props.id = --Activator.prototype.idpool;
        }
        model = gg.activators[props.type] || gg.activators.err;
        if (model.anim != null) {
          anim = JSON.parse(JSON.stringify(model.anim));
        }
        sprite = {
          elevation: model.elevation,
          path: model.texture,
          hasShadow: model.hasShadow,
          x: model.x || 0,
          sprite: {
            width: model.sprite.width,
            height: model.sprite.height
          },
          sheet: {
            width: model.sheet.width,
            height: model.sheet.height
          }
        };
        super(props, sprite);
        this.understeer = false;
        this.anim = anim;
        this.model = model;
        this.build();
        this.type = 'Activator';
        this.frame(model.frame || 0, model.y);
        if (model.solid) {
          this.embody();
        }
        this.state(props, true);
        this.pose();
      }

      patch(o) {
        super.patch(o);
        this.state(o);
        return true;
      }

      embody() {
        var x, y;
        this.bodyDef = new box2d.b2BodyDef();
        this.bodyDef.type = box2d.b2BodyType.b2_staticBody;
        x = this.props.x / gg.scaling;
        y = this.props.y / gg.scaling;
        this.bodyDef.position.Set(x, y);
        this.polygonShape = new box2d.b2PolygonShape;
        this.polygonShape.SetAsBox((this.model.sprite.width / 2) / gg.scaling, (this.model.sprite.height / 2) / gg.scaling);
        this.fixtureDef = new box2d.b2FixtureDef;
        this.fixtureDef.shape = this.polygonShape;
        this.fixtureDef.filter.categoryBits = gg.masks.solid;
        this.fixtureDef.filter.maskBits = -1;
        this.body = gg.world.CreateBody(this.bodyDef);
        this.body.SetTransform(this.body.GetPosition(), this.props.r);
        this.body.CreateFixture(this.fixtureDef);
        return true;
      }

      dtor() {
        this.mesh.ggsolid = null;
        super.dtor(1);
        return true;
      }

      state() {
        return 0;
      }

      step() {
        var frame;
        super.step();
        if (this.anim != null) {
          gg.anim.call(this.anim);
          frame = this.anim.i;
          this.frame(frame, this.model.y);
        }
        this.pose();
        return true;
      }

    };

    Activator.prototype.idpool = 0;

    return Activator;

  }).call(this);

  gg.Furniture = class Furniture extends gg.Activator {
    constructor(props) {
      super(props);
    }

  };

  gg.ATM = class ATM extends gg.Activator {
    constructor(props) {
      super(props);
    }

    state(o) {}

    //true
    gui() {
      return 0;
    }

    // override
    dtor() {
      return super.dtor();
    }

  };

  gg.VendingMachine = class VendingMachine extends gg.Activator {
    constructor(props) {
      super(props);
    }

    state(o) {}

    //true
    gui() {
      return 0;
    }

    // override
    dtor() {
      return super.dtor();
    }

  };

  gg.LabFreezer = class LabFreezer extends gg.Activator {
    constructor(props) {
      var x, y;
      super(props);
      x = props.x + 5 * Math.cos(props.r - (Math.PI / 2));
      y = props.y + 5 * Math.sin(props.r - (Math.PI / 2));
    }

    /*@light = new THREE.PointLight 0xa7bcff, .6, 64
    @light.position.set x, y, @props.z + 8
    gg.scene.add @light

    gg.map.build = true*/
    //state: (o) ->
    //if o.states.u?

    //true

    //true
    gui() {
      return 0;
    }

    // override
    dtor() {
      gg.scene.remove(this.light);
      return super.dtor();
    }

  };

  gg.VacuumOven = class VacuumOven extends gg.Activator {
    constructor(props) {
      var x, y;
      super(props);
      x = props.x + 5 * Math.cos(props.r - (Math.PI / 2));
      y = props.y + 5 * Math.sin(props.r - (Math.PI / 2));
    }

    /*@light = new THREE.PointLight 0xa7bcff, .6, 64
    @light.position.set x, y, @props.z + 8
    gg.scene.add @light

    gg.map.build = true*/
    gui() {
      return 0;
    }

    // override
    dtor() {
      gg.scene.remove(this.light);
      return super.dtor();
    }

  };

  gg.Incubator = class Incubator extends gg.Activator {
    constructor(props) {
      var x, y;
      super(props);
      x = props.x + 8 * Math.cos(props.r - (Math.PI / 2));
      y = props.y + 8 * Math.sin(props.r - (Math.PI / 2));
    }

    /*@light = new THREE.PointLight 0xa7bcff, .6, 64
    @light.position.set x, y, @props.z + 8
    gg.scene.add @light

    gg.map.build = true*/
    //state: (o) ->
    //if o.states.u?

    //true

    //true
    gui() {
      return 0;
    }

    // override
    dtor() {
      gg.scene.remove(this.light);
      return super.dtor();
    }

  };

  gg.Generator = class Generator extends gg.Activator {
    constructor(props) {
      super(props);
      //@light = new THREE.PointLight 0xff8f8f, .6, 32
      //@light.position.set @props.x, @props.y, @props.z + 8
      //gg.scene.add @light
      gg.map.build = true;
    }

    // override
    dtor() {
      //gg.scene.remove @light
      return super.dtor();
    }

  };

  gg.Worklight = class Worklight extends gg.Activator {
    constructor(props) {
      super(props);
      this.light = null;
    }

    state(o) {
      if (o.states == null) {
        return;
      }
      if (o.states.o != null) {
        if (o.states.o && ((gg.interior != null) && (o.states.intr != null) || (gg.interior == null))) {
          if (this.light == null) {
            this.light = new THREE.PointLight(0xffffff, 2, 64 * 5);
            this.light.position.set(this.props.x, this.props.y, this.props.z + 24);
            gg.scene.add(this.light);
            gg.map.build = true;
          }
        } else if (this.light != null) {
          gg.scene.remove(this.light);
          this.light = null;
          gg.map.build = true;
        }
      }
      return true;
    }

    // override
    dtor() {
      if (this.light != null) {
        gg.scene.remove(this.light);
      }
      return super.dtor();
    }

  };

  gg.Terminal = class Terminal extends gg.Activator {
    constructor(props) {
      var x, y;
      super(props);
      x = props.x + 5 * Math.cos(props.r - (Math.PI / 2));
      y = props.y + 5 * Math.sin(props.r - (Math.PI / 2));
      /*@light = new THREE.PointLight 0xa7bcff, .6, 64
      @light.position.set x, y, @props.z + 8
      gg.scene.add @light

      gg.map.build = true*/
      this.thing = '<om:terminal> <om:screen> Terminal... </om:screen> <om:deck> <!-- <om:vent></om:vent> <om:vent></om:vent> <om:vent></om:vent> <om:vent></om:vent> <om:vent></om:vent> --> <om:power>onn</om:power> <!-- <om:knob></om:knob> --> </om:deck> </om:terminal>';
    }

    // $('#overlay').append @thing

    // override
    state(o) {
      if (o.states == null) {
        return;
      }
      // if o.states.use?
      return true;
    }

    // override
    dtor() {
      if (this.light != null) {
        gg.scene.remove(this.light);
      }
      return super.dtor();
    }

  };

  gg.Teleporter = class Teleporter extends gg.Activator {
    constructor(props) {
      super(props);
      this.light = null;
      this.topmaterial = new THREE.MeshLambertMaterial({
        color: !this.props.interior ? gg.ambient : gg.intrcolor,
        map: this.sty,
        transparent: true,
        side: THREE.FrontSide
      });
      this.topgeometry = new THREE.PlaneBufferGeometry(this.sprite.sprite.width * this.sprite.scale, this.sprite.sprite.height * this.sprite.scale, 1);
      this.topmesh = new THREE.Mesh(this.topgeometry, this.topmaterial);
      this.topmesh.position.set(this.props.x, this.props.y, this.props.z + 12);
      this.topmesh.rotation.z = this.props.r;
      gg.scene.add(this.topmesh);
      this.frame(1, this.model.y, this.topgeometry);
    }

    state(o) {
      if (o.states == null) {
        return;
      }
      if (o.states.o != null) {
        if (o.states.o && ((gg.interior != null) && (o.states.intr != null) || (gg.interior == null))) {
          if (this.light == null) {
            this.light = new THREE.PointLight(0xc3d1ff, 2, 256);
            this.light.position.set(this.props.x, this.props.y, this.props.z + 32);
            gg.scene.add(this.light);
            gg.map.build = true;
          }
        } else if (this.light != null) {
          gg.scene.remove(this.light);
          this.light = null;
          gg.map.build = true;
        }
      }
      return true;
    }

    // override
    dtor() {
      gg.scene.remove(this.topmesh);
      if (this.light != null) {
        gg.scene.remove(this.light);
      }
      return super.dtor();
    }

  };

  gg.Cable = (function() {
    class Cable {
      constructor(props) {
        var cable;
        console.log("new cable ");
        cable = this.power;
      }

      dtor() {}

    };

    Cable.power = {
      sprite: {
        width: 8,
        height: 31
      },
      sheet: {
        width: 128,
        height: 128
      },
      x: 120,
      y: 1 - ((1 / 128) * 13),
      frame: 0
    };

    return Cable;

  }).call(this);

  gg.Dumpster = class Dumpster extends gg.Activator {
    constructor(props) {
      super(props);
    }

  };

}).call(this);
