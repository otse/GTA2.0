// Generated by CoffeeScript 2.3.0
(function() {
  gg.Player = class Player extends gg.Man {
    constructor(props) {
      super(props);
      this.type = 'Player';
      gg.ply = this;
      // gg.zoom = gg.C.ZOOM.PED
      props.net = false;
      this.lastSound = null;
      this.lastStep = 0;
      this.footy = false;
      this.LASTW = this._MAN.gallop;
      // @embody()

      // console.log props
      this.oldish = {
        x: props.x,
        y: props.y,
        z: props.z,
        r: 0
      };
    }

    // part.mesh.visible = false for part in @parts
    dtor() {
      if (this === gg.ply) {
        gg.ply = null;
      }
      super.dtor();
      return 1;
    }

    // override
    embody() {
      // console.log 'ply emb'
      if (this.dynamicBody != null) {
        gg.world.DestroyBody(this.dynamicBody);
        this.dynamicBody = null;
      }
      super.embody();
      this.dynamicBody.SetLinearDamping(15);
      this.dynamicBody.SetAngularDamping(3);
      return 1;
    }

    // override
    patch(o) {
      // console.log o
      this.state(o);
      return 1;
    }

    // overide
    state(o, first = false) {
      var wep, wrhbhr;
      if (o.states == null) {
        return;
      }
      super.state(o, first);
      if (o.states.g != null) {
        wep = gg.weps[this._MAN.using] || null;
        if (!wep) {
          return;
        }
        wrhbhr = (function() {
          switch (wep.type) {
            case 'Handgun':
              return 2;
            case 'SMG':
              return 2;
            case 'Carbine':
              return 3;
            case 'Shotgun':
              return 5;
            case 'AR':
              return 4;
            case 'DMR':
              return 5;
            case 'Sniper':
              return 6;
          }
        })();
        gg.quake = wrhbhr;
      }
      return 1;
    }

    die() { // todo, handle this with man's states.d
      gg.zoom = gg.C.ZOOM.DEAD;
      this.dead = true;
      this.shadow.visible = false;
      this.sprite.elevation = 1;
      // part.sprite.elevation = 1 for part in @parts
      gg.play(gg.sounds.screams[Math.floor(Math.random() * 4)], this);
      this.frame(4, this.falls.y);
      return 1;
    }

    // override
    step() {
      super.step();
      return 0;
    }

    steps() {
      var A, D, S, W, a, aim, angle, d, force, forces, nomove, pos, r, ref, s, theta, to, w, x, y;
      if (this.dead) {
        this.pose();
        return;
      }
      if ((this.car != null) || (this.dynamicBody == null)) {
        return;
      }
      a = gg.keys[65];
      d = gg.keys[68];
      w = gg.keys[87];
      s = gg.keys[83];
      A = a && !d;
      S = s && !w;
      W = w && !s;
      D = d && !a;
      if (gg.aim) {
        aim = true;
        pos = gg.mouse2d;
        theta = Math.atan2(this.props.x - pos.x, this.props.y - pos.y);
        r = theta; // - Math.PI/2
        if (r < 0) {
          r += Math.PI * 2;
        }
        r = -r;
        if (!this.freeze) {
          this.props.r = r;
        }
        gg.ply.dynamicBody.SetTransform(gg.ply.dynamicBody.GetPosition(), r);
      }
      if (gg.keys[16] === 1) { // shift
        this._MAN.gallop = !this._MAN.gallop;
        this.LASTW = this._MAN.gallop ? 2 : 1;
        if (gg.net != null) {
          gg.net.out.W = this.LASTW;
        }
      }
      // copy physics
      this.dynamicBody.SetAngularVelocity(0);
      //@dynamicBody.SetLinearVelocity new box2d.b2Vec2 0, 0
      if (!this.freeze) {
        pos = this.dynamicBody.GetPosition();
        this.props.x = pos.x * gg.scaling;
        this.props.y = pos.y * gg.scaling;
        this.props.r = this.dynamicBody.GetAngle();
      }
      // @pose() # we already pose at bottom
      this._MAN.moving = W || S;
      this._MAN.turning = A || D;
      if (aim) {
        if (this._MAN.moving || this._MAN.turning) {
          this._MAN.moving = true;
        }
        if (this.LASTW !== 1) {
          this.LASTW = 1;
          if ((ref = gg.net) != null) {
            ref.out.W = 1;
          }
        }
      }
      if (aim && (a || d || w || s)) {
        force = 40;
        force *= gg.delta;
        force *= 20;
        //force *= 45
        angle = 0;
        if (A && W) {
          angle = Math.PI * 0.75;
        } else if (D && W) {
          angle = Math.PI * 0.25;
        } else if (A && S) {
          angle = Math.PI * 1.25;
        } else if (D && S) {
          angle = Math.PI * 1.75;
        } else if (A) {
          angle = Math.PI * 1.0;
        } else if (S) {
          angle = Math.PI * 1.5;
        } else if (W) {
          angle = Math.PI * 0.5;
        } else if (D) {
          angle = 0;
        } else {
          nomove = true;
        }
        if (!nomove) {
          x = force * Math.cos(angle);
          y = force * Math.sin(angle);
          to = new box2d.b2Vec2(x, y);
          this.dynamicBody.ApplyForce(to, this.dynamicBody.GetWorldCenter());
        }
      }
      if (this._MAN.turning && !aim) {
        r = 0;
        if (A && !D) {
          r = 0.1;
        }
        if (D && !A) {
          r = -0.1;
        }
        this.dynamicBody.SetTransform(this.dynamicBody.GetPosition(), this.props.r + r);
      }
      if (this._MAN.moving && !aim) {
        forces = [40, -20];
        force = 0;
        force = W ? forces[0] : forces[1];
        force *= gg.delta;
        force *= this._MAN.gallop ? 40 : 20;
        angle = this.props.r - (Math.PI / 2);
        x = force * Math.cos(angle);
        y = force * Math.sin(angle);
        to = new box2d.b2Vec2(x, y);
        this.dynamicBody.ApplyForce(to, this.dynamicBody.GetWorldCenter());
      }
      if ((gg.net != null) && gg.keys[32]) {
        /*if @props.r > gg.C.PII
        @props.r = @props.r - gg.C.PII
        		else if @props.r < 0
        @props.r = gg.C.PII - @props.r*/
        // shooting
        gg.net.out.T = 1;
      }
      
      // @zoom = 0

      // @animate()
      // @pose()
      return 1;
    }

  };

}).call(this);
