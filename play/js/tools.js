// Generated by CoffeeScript 2.3.0
(function() {
  var anistonbd4, bug, increment, man, truck, wellard;

  gg.visualFactory = function(props) {
    var visual;
    visual = (function() {
      switch (props.type) {
        case 'Surface':
          return new gg.Surface(props);
        case 'Block':
          return new gg.Block(props);
        // when 'Wall' then new gg.Wall props
        case 'Neon':
          return new gg.Neon(props);
        case 'Entity':
          return new gg.Entity(props);
        case 'Light':
          return new gg.Light(props);
        case 'Walk':
          return new gg.Walk(props);
        case 'Drive':
          return new gg.Drive(props);
        case 'Parking space':
          return new gg.ParkingSpace(props);
        case 'Safe Zone':
          return new gg.SafeZone(props);
        case 'Player':
          return new gg.Player(props);
        case 'Zombie':
          return new gg.Zombie(props);
        // when 'Guy' then new gg.Guy props
        case 'Man':
          return new gg.Man(props);
        case 'Car':
          return new gg.Car(props);
        case 'Decal':
          return new gg.Decal(props);
        case 'Door':
          return new gg.Door(props);
        case 'Tree':
          return new gg.Tree(props);
        case 'Table':
          return new gg.Activator(props);
        case 'Desk':
          return new gg.Activator(props);
        case 'Chair':
          return new gg.Activator(props);
        case 'Couch':
          return new gg.Activator(props);
        case 'Generator':
          return new gg.Generator(props);
        case 'Worklight':
          return new gg.Worklight(props);
        case 'Lab Freezer':
          return new gg.LabFreezer(props);
        case 'Vacuum Oven':
          return new gg.VacuumOven(props);
        case 'Incubator':
          return new gg.Incubator(props);
        case 'Terminal':
          return new gg.Terminal(props);
        case 'Teleporter':
          return new gg.Teleporter(props);
        case 'ATM':
          return new gg.ATM(props);
        case 'Vending Machine':
          return new gg.VendingMachine(props);
        case 'Dumpster':
          return new gg.Dumpster(props);
        case 'Pickup':
          return new gg.Pickup(props);
        default:
          console.error(`unknown visual type \`${props.type}\``);
          return visual = new gg.Visual(props);
      }
    })();
    return visual;
  };

  gg.mksty = function(sty, app) {
    var beh, slash;
    beh = sty.split('.');
    slash = beh[0].lastIndexOf('/');
    //if beh[0].charAt(slash+1) is 'n'
    return `${beh[0]}${app}.${beh[1]}`;
    //else
    //return no
    return 0;
  };

  // unused legacy func
  gg.addrtochunk = function(props) {
    var hash, x, y;
    x = Math.floor(props.x / gg.C.CHUNITS);
    y = Math.floor(props.y / gg.C.CHUNITS);
    hash = `${x},${y}`;
    gg.map.offChunks[hash].addr(props);
    //gg.scene.add f
    console.log(`adding to ${x},${y}`);
    return true;
  };

  gg.play = function(sound, v, dist) {
    var audio, buffer;
    if (gg.nosound) {
      return;
    }
    if (Array.isArray(sound)) {
      sound = sound[Math.floor(Math.random() * sound.length)];
    }
    buffer = gg.audio[sound];
    if (!(buffer instanceof AudioBuffer)) {
      return;
    }
    audio = new THREE.PositionalAudio(gg.listener);
    // audio.panner.panningModel = 'HRTF'
    audio.setBuffer(buffer);
    audio.position.set(v.props.x, v.props.y, v.props.z);
    audio.setRefDistance(dist || 30);
    audio.play();
    gg.scene.add(audio);
    return 1;
  };

  gg.distant = function(sound, id, x, y) {
    // sound.pos3d x, y, 0.5, id
    return 1;
  };

  gg.loadSty = function(file, smooth = false, key) {
    var loader, path;
    if (key == null) {
      key = file;
    }
    path = `play/sty/${file}`;
    if (!gg.textures[key]) {
      THREE.TextureLoader();
      loader = new THREE.TextureLoader;
      gg.textures[key] = loader.load(path, function(t) {
        t.generateMipmaps = false;
        // t.anisotropy = gg.maxAnisotropy
        if (!smooth) {
          t.magFilter = THREE.NearestFilter;
          return t.minFilter = THREE.NearestFilter;
        }
      });
    }
    // t.magFilter = THREE.LinearFilter
    // t.minFilter = THREE.LinearMipMapLinearFilter
    return gg.textures[key];
  };

  gg.bubble = function(q, hold) {
    this.r = $('<div class="bubble">');
    this.e = $('<div class="in">');
    this.r.append(this.e);
    this.e.append(q);
    $('#bubbles').append(this.r);
    this.r.animate({
      'margin-top': 0,
      opacity: 1
    }, 600);
    /*
    var dismiss = $('<span class="dismiss">dismiss</span>');
    dismiss.click(function(){$(this).parent().remove();});
    e.append(dismiss);
    */
    this.slideaway = function() {
      var e;
      e = this.e;
      e.delay(7000).animate({
        'margin-left': -(e.width() + 40),
        opacity: 0
      }, 1200, function() {
        return $(this).remove();
      });
      return true;
    };
    if (!hold) {
      this.slideaway();
    }
    return this;
  };

  gg.anim = function(reset) {
    if (reset) {
      delete this.timer;
      delete this.i;
      delete this.done;
      delete this.first;
      return;
    }
    if (this.done == null) {
      this.done = false;
    }
    this.timer = this.timer != null ? this.timer + gg.delta : 0;
    if (this.i == null) {
      this.i = this.start || 0;
    }
    if (!(this.timer >= this.moment)) {
      return;
    }
    if (this.i === this.frames - 1) {
      this.done = true;
      this.i = -1;
    } else if ((this.start != null) && this.first && this.i === this.start) {
      this.done = true;
      this.i = -1;
    } else if (this.i === 0) {
      this.done = false;
      if (this.inverse) {
        this.i = this.frames - 1;
      }
    }
    if (this.inverse) {
      this.i--;
    } else {
      this.i++;
    }
    this.timer = 0;
    if (this.first == null) {
      this.first = true;
    }
    return 1;
  };

  gg.posplane = function(geom, face, x, y, w, h) {
    var a, i, k, o;
    o = face * 8;
    // 0 1, 1 1, 0 0, 1 0
    // left top, right top, left bottom, right bottom

    //   [ x,y, x+w,y, x,y+h, x+w,y+h ]
    a = [x, y + h, x + w, y + h, x, y, x + w, y];
    for (i = k = 0; k <= 7; i = ++k) {
      geom.attributes.uv.array[o + i] = a[i];
    }
    geom.attributes.uv.needsUpdate = true;
    return 100110;
  };

  gg.flipplane = function(geom, face, flip, reset) {
    var a, flips, i, k, o, yn;
    o = face * 8;
    a = geom.attributes.uv.array;
    flips = [[a[o + 0], a[o + 1], a[o + 2], a[o + 3], a[o + 4], a[o + 5], a[o + 6], a[o + 7]], [a[o + 2], a[o + 3], a[o + 0], a[o + 1], a[o + 6], a[o + 7], a[o + 4], a[o + 5]]];
    yn = flip ? 1 : 0;
    for (i = k = 0; k <= 7; i = ++k) {
      geom.attributes.uv.array[o + i] = flips[yn][i];
    }
    geom.attributes.uv.needsUpdate = true;
    return true;
  };

  gg.rotateplane = function(geom, face, turns) {
    var a, i, k, o;
    o = face * 8;
    // 0 1, 1 1, 0 0, 1 0
    // left top, right top, left bottom, right bottom
    a = geom.attributes.uv.array;
    switch (turns) {
      case 1:
        a = [a[o + 4], a[o + 5], a[o + 0], a[o + 1], a[o + 6], a[o + 7], a[o + 2], a[o + 3]];
        break;
      case 2:
        a = [a[o + 6], a[o + 7], a[o + 4], a[o + 5], a[o + 2], a[o + 3], a[o + 0], a[o + 1]];
        break;
      case 3:
        a = [a[o + 2], a[o + 3], a[o + 6], a[o + 7], a[o + 0], a[o + 1], a[o + 4], a[o + 5]];
    }
    for (i = k = 0; k <= 7; i = ++k) {
      geom.attributes.uv.array[o + i] = a[i];
    }
    geom.attributes.uv.needsUpdate = true;
    return true;
  };

  gg.rotateUv = function(uvs, o, turns) {
    var f, i, j, k, l, m, newy, ref, ref1, ref2, s;
    newy = [];
    if (o > 0) {
      for (i = k = 0, ref = o - 1; (0 <= ref ? k <= ref : k >= ref); i = 0 <= ref ? ++k : --k) {
        newy.push(null);
      }
    }
    f = o;
    s = o + 1;
    switch (turns) {
      case 1:
        newy.push([
          {
            x: uvs[f][1].x,
            y: uvs[f][1].y
          },
          {
            x: uvs[s][1].x,
            y: uvs[s][1].y
          },
          {
            x: uvs[f][0].x,
            y: uvs[f][0].y
          }
        ]);
        newy.push([
          {
            x: uvs[s][1].x,
            y: uvs[s][1].y
          },
          {
            x: uvs[f][2].x,
            y: uvs[f][2].y
          },
          {
            x: uvs[f][0].x,
            y: uvs[f][0].y
          }
        ]);
        break;
      case 2:
        newy.push([
          {
            x: uvs[s][1].x,
            y: uvs[s][1].y
          },
          {
            x: uvs[s][2].x,
            y: uvs[s][2].y
          },
          {
            x: uvs[s][0].x,
            y: uvs[s][0].y
          }
        ]);
        newy.push([
          {
            x: uvs[f][2].x,
            y: uvs[f][2].y
          },
          {
            x: uvs[f][0].x,
            y: uvs[f][0].y
          },
          {
            x: uvs[f][1].x,
            y: uvs[f][1].y
          }
        ]);
        break;
      case 3:
        newy.push([
          {
            x: uvs[f][2].x,
            y: uvs[f][2].y
          },
          {
            x: uvs[f][0].x,
            y: uvs[f][0].y
          },
          {
            x: uvs[s][1].x,
            y: uvs[s][1].y
          }
        ]);
        newy.push([
          {
            x: uvs[f][0].x,
            y: uvs[f][0].y
          },
          {
            x: uvs[s][0].x,
            y: uvs[s][0].y
          },
          {
            x: uvs[s][1].x,
            y: uvs[s][1].y
          }
        ]);
        break;
      default:
        return;
    }
    for (j = l = ref1 = f, ref2 = s; (ref1 <= ref2 ? l <= ref2 : l >= ref2); j = ref1 <= ref2 ? ++l : --l) {
      for (i = m = 0; m <= 2; i = ++m) {
        uvs[j][i].x = newy[j][i].x;
        uvs[j][i].y = newy[j][i].y;
      }
    }
    return true;
  };

  gg.flipUv = function(uvs, o, flip) {
    var a, b, c;
    a = [[[0, 1], [0, 0], [1, 1]], [[0, 0], [1, 0], [1, 1]]];
    b = [[[1, 1], [1, 0], [0, 1]], [[1, 0], [0, 0], [0, 1]]];
    c = flip ? b : a;
    // left top
    uvs[o][0].x = c[0][0][0];
    uvs[o][0].y = c[0][0][1];
    // left bottom
    uvs[o][1].x = c[0][1][0];
    uvs[o][1].y = c[0][1][1];
    // right top
    uvs[o][2].x = c[0][2][0];
    uvs[o][2].y = c[0][2][1];
    // left bottom
    uvs[o + 1][0].x = c[1][0][0];
    uvs[o + 1][0].y = c[1][0][1];
    // right bottom
    uvs[o + 1][1].x = c[1][1][0];
    uvs[o + 1][1].y = c[1][1][1];
    // right top
    uvs[o + 1][2].x = c[1][2][0];
    uvs[o + 1][2].y = c[1][2][1];
    return 1;
  };

  gg.pivot = function(point2x, point2y, deg, centerX, centerY) {
    var newX, newY;
    newX = centerX + (point2x - centerX) * Math.cos(deg) - (point2y - centerY) * Math.sin(deg);
    newY = centerY + (point2x - centerX) * Math.sin(deg) + (point2y - centerY) * Math.cos(deg);
    return {
      x: newX,
      y: newY
    };
  };

  gg.shadeColor2 = function(color, percent) {
    var B, G, R, f, p, t;
    f = parseInt(color.slice(1), 16);
    t = percent < 0 ? 0 : 255;
    p = percent < 0 ? percent * -1 : percent;
    R = f >> 16;
    G = f >> 8 & 0x00FF;
    B = f & 0x0000FF;
    return (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
  };

  gg.darker = function(v) {
    var color, darker;
    color = !(v != null ? v.props.interior : void 0) ? gg.ambient : gg.intrcolor;
    color = `#${color.toString(16)}`;
    color = color.toUpperCase();
    darker = parseInt(`0x${gg.shadeColor2(color, -.1)}`);
    return darker;
  };

  increment = 0;

  gg.material = function(sty, v, salt, lambert) {
    var def, key, normalMap, options;
    if (salt == null) {
      salt = '';
    }
    if (gg.ed != null) {
      salt = `${salt}Unique${increment++}`;
    }
    if (v != null) {
      if (v.props.interior) {
        salt = `${salt}Interior`;
      }
      if (gg.settings.localMaterials && (v.chunk != null)) {
        // else if gg.interior?
        // salt = "#{salt}Exterior"
        salt = `${salt}Chunk${v.chunk.hash}`;
      }
    }
    key = `${sty}${salt}`;
    def = gg.definitions[sty];
    normalMap = null;
    // key = "same"
    if (def != null) {
      // console.log "def for #{sty}"
      normalMap = gg.loadSty(def != null ? def.normalPath : void 0);
    }
    if (gg.materials[key] == null) {
      if (lambert) { // and gg.settings.simpleShading
        options = {
          // color: if not v?.props.interior then gg.ambient else gg.intrcolor
          map: gg.loadSty(sty),
          transparent: !!~sty.indexOf('.png'),
          side: THREE.FrontSide
        };
        gg.materials[key] = new THREE.MeshLambertMaterial(options);
      } else {
        options = {
          // color: if not v?.props.interior then gg.ambient else gg.intrcolor
          map: gg.loadSty(sty),
          specularMap: gg.loadSty(sty),
          normalMap: normalMap,
          normalScale: new THREE.Vector2(.5, .5),
          shininess: 6,
          transparent: !!~sty.indexOf('.png'),
          side: THREE.FrontSide
        };
        
        //options.shininess = 10
        //options.specular = 0x646464
        //options.specularMap = options.map
        gg.materials[key] = new THREE.MeshPhongMaterial(options);
      }
      if (!!~salt.indexOf('Sloped')) {
        gg.materials[key].color = new THREE.Color(gg.darker(v));
      }
    }
    return gg.materials[key];
  };

  man = {
    normalPath: 'nontile/man/normal.png',
    seeThrough: true
  };

  bug = {
    normalPath: 'nontile/cars/bugnormal.png'
  };

  truck = {
    normalPath: 'nontile/cars/trucknormal.png'
  };

  wellard = {
    normalPath: 'nontile/cars/wellardnormal.png'
  };

  anistonbd4 = {
    normalPath: 'nontile/cars/anistonbd4normal.png'
  };

  gg.definitions = {
    'nontile/man/white.png': man,
    'nontile/man/ponchohood.png': man,
    'nontile/man/surgical.png': man,
    'nontile/man/gloves.png': man,
    'nontile/man/leather.png': man,
    'nontile/man/black.png': man,
    'nontile/man/loafers.png': man,
    'nontile/man/sneakers.png': man,
    'nontile/man/dress.png': man,
    'nontile/man/jeans.png': man,
    'nontile/man/denim.png': man,
    'nontile/man/khaki.png': man,
    'nontile/man/poncho.png': man,
    'nontile/man/sweater.png': man,
    'nontile/man/bomber.png': man,
    'nontile/man/parka.png': man,
    'nontile/man/commando.png': man,
    'nontile/man/shirt.png': man,
    'nontile/man/brown.png': man,
    'nontile/man/bald.png': man,
    'nontile/man/blackhair.png': man,
    'nontile/man/handgun.png': man,
    'nontile/man/smg.png': man,
    'nontile/man/carbine.png': man,
    'nontile/man/ar.png': man,
    'nontile/man/shotgun.png': man,
    'nontile/man/dmr.png': man,
    'nontile/man/sniper.png': man,
    'nontile/cars/schoolbus.png': {
      normalPath: 'nontile/cars/schoolbusnormal.png'
    },
    'nontile/cars/firetruck.png': {
      normalPath: 'nontile/cars/firetrucknormal.png'
    },
    'nontile/cars/specialagentcar.png': {
      normalPath: 'nontile/cars/specialagentcarnormal.png'
    },
    'nontile/cars/landroamer.png': {
      normalPath: 'nontile/cars/landroamernormal.png'
    },
    'nontile/cars/bug.png': bug,
    'nontile/cars/bug_blue.png': bug,
    'nontile/cars/truck.png': truck,
    'nontile/cars/wellard.png': wellard,
    'nontile/cars/anistonbd4.png': anistonbd4
  };

}).call(this);
