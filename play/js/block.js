// Generated by CoffeeScript 2.3.0
(function() {
  gg.C.faceNames = ['right', 'left', 'front', 'back', 'top', 'bottom'];

  gg.C.faceNamesOpposite = ['left', 'right', 'back', 'front', 'bottom', 'top'];

  gg.C.rotateNames = ['rright', 'rleft', 'rfront', 'rback', 'rtop', 'rbottom'];

  gg.C.faces = {
    0: 0,
    1: 0,
    2: 1,
    3: 1,
    4: 2,
    5: 2,
    6: 3,
    7: 3,
    8: 4,
    9: 4
  };

  gg.Block = class Block extends gg.Visual {
    // @color: 0xffffff
    constructor(props) {
      var z;
      super(props);
      this.type = 'Block';
      if (props.r == null) {
        props.r = 0;
      }
      if (props.f == null) {
        props.f = 0;
      }
      this.top = 4;
      z = (props.z + 1) * 64;
      this.raise = {
        z: z,
        tl: z,
        tr: z,
        bl: z,
        br: z,
        mean: z
      };
      this.tile = `${Math.floor(this.props.x)},${Math.floor(this.props.y)}`;
    }

    dtor() {
      var ref;
      if ((ref = this.chunk) != null) {
        delete ref.tiles[this.tile];
      }
      if (this.body != null) {
        gg.world.DestroyBody(this.body);
      }
      super.dtor();
      return 1;
    }

    build(solo) {
      var base, name;
      console.log("block build");
      this.shape();
      this.pose();
      if ((base = this.chunk.tiles)[name = this.tile] == null) {
        base[name] = [];
      }
      this.chunk.tiles[this.tile].push(this);
      super.build(solo);
      return 1;
    }

    pose() {
      var x, y, z;
      x = (this.props.x * 64) + 32;
      y = (this.props.y * 64) + 32;
      z = (this.props.z * 64) + 32;
      if (this.mesh) {
        this.mesh.position.x = x;
        this.mesh.position.y = y;
        this.mesh.position.z = z;
      }
      this.mesh.updateMatrix();
      this.mesh.updateMatrixWorld();
      if (!this.body && this.props.z === 1) {
        this.embody();
      }
      return true;
    }

    shape() {
      var bin, box, i, j;
      this.makematerials();
      if ((this.props.s != null) || (this.props.w != null) || (gg.ed != null)) {
        this.geometry = gg.box.clone();
      // @top = 4
      } else if (gg.ed == null) {
        bin = '';
        for (i = j = 0; j <= 4; i = ++j) {
          bin += this.props[gg.C.faceNames[i]] != null ? '1' : '0';
        }
        this.bin = bin = bin.toString().replace(/[\s,]/g, '');
        box = gg.boxes[`${bin}`];
        this.top = box.gg.top;
        this.geometry = box.clone();
      }
      if (this.props.f) {
        gg.flipplane(this.geometry, this.top, true);
      }
      if (this.props.r) {
        gg.rotateplane(this.geometry, this.top, this.props.r);
      }
      this.slope();
      this.wedge();
      this.material = this.materials;
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mesh.castShadow = true;
      this.mesh.receiveShadow = false;
      // @mesh.frustumCulled = false
      this.mesh.matrixAutoUpdate = false;
      gg.block = this;
      this.mesh.ggsolid = this; // arb prop
      return 1;
    }

    slope() {
      var i, incline, p, ref, s;
      if (this.props.s == null) {
        return;
      }
      ref = this.props.s;
      // console.log @geometry.attributes.position.array
      for (i in ref) {
        incline = ref[i];
        if (!incline) { // ! 0
          continue;
        }
        p = this.geometry.attributes.position.array;
        this.geometry.attributes.position.needsUpdate = true;
        s = 32 + (8 * incline);
        // console.log "incline to #{s}"
        switch (parseInt(i)) { // ! important
          case 0: // n
            this.raise.tl = this.raise.z + s;
            this.raise.tr = this.raise.z + s;
            p[2] = s; // tr of right
            p[17] = s; // tl of left
            p[32] = s; // tl of front
            p[35] = s; // tr of front
            p[50] = s; // tl of top
            p[53] = s; // tr of top
            break;
          case 1: // e
            this.raise.tr = this.raise.z + s;
            this.raise.br = this.raise.z + s;
            p[35] = s; // tr of front
            p[41] = s; // br of back
            p[2] = s; // tr of right
            p[8] = s; // br of right
            p[53] = s; // tr of top
            p[59] = s; // br of top
            break;
          case 2: // s
            this.raise.bl = this.raise.z + s;
            this.raise.br = this.raise.z + s;
            p[8] = s; // br of right
            p[23] = s; // bl of left
            p[38] = s; // bl of back
            p[41] = s; // br of back
            p[59] = s; // br of top
            p[56] = s; // bl of top
            break;
          case 3: // w
            this.raise.tl = this.raise.z + s;
            this.raise.bl = this.raise.z + s;
            p[32] = s; // tl of front
            p[38] = s; // bl of back
            p[17] = s; // tl of left
            p[23] = s; // bl of left
            p[50] = s; // tl of top
            p[56] = s; // bl of top
        }
      }
      this.raise.mean = (this.raise.tl + this.raise.tr + this.raise.bl + this.raise.br) / 4;
      return 1;
    }

    wedge() {
      var doit, i, p, ref, w;
      if (this.props.w == null) {
        return;
      }
      ref = this.props.w;
      // console.log @geometry.attributes.position.array
      for (i in ref) {
        doit = ref[i];
        if (!doit) { // ! 0
          continue;
        }
        p = this.geometry.attributes.position.array;
        this.geometry.attributes.position.needsUpdate = true;
        w = 32;
        // 0:0,1:0,  2:1,3:1,  4:2,5:2,  6:3,7:3,  8:4,9:4
        // 0			1		2		3		4		5
        // 'right', 'left', 'front', 'back', 'top', 'bottom'
        switch (parseInt(i)) { // ! important
          case 0: // ne
            p[0] = -32; // tr of right
            p[3] = -32; // tr-1 of right
            p[33] = -32; // tr of front
            p[27] = -32; // tr-1 of front
            p[51] = -32; // tr of top
            break;
          case 1: // se
            p[6] = -32; // br of right
            p[9] = -32; // br-1 of right
            p[39] = -32; // br of back
            p[45] = -32; // br-1 of back
            p[57] = -32; // br of top
            break;
          case 2: // sw
            p[18] = 32; // bl-1 of left
            p[21] = 32; // bl of left
            p[36] = 32; // bl of back
            p[42] = 32; // bl-1 of back
            p[54] = 32; // bl of top
            break;
          case 3: // nw
        }
      }
      return 1;
    }

    makematerials() {
      var f, i, j, len, ref, salt;
      this.materials = [];
      ref = gg.C.faceNames;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        f = ref[i];
        if (this.props[f] != null) {
          if (i === 4) { // top
            salt = this.props.s != null ? 'Sloped' : '';
            this.materials[i] = gg.material(this.props[f], this, salt, true);
          } else {
            this.materials[i] = gg.material(this.props[f], this, 'Lamb', true);
          }
        } else {
          this.materials[i] = gg.ed == null ? gg.C.invisible : gg.material('special/null/null.bmp');
        }
      }
      // @materials[i] = gg.material 'special/null/null.bmp'
      // m.visible = false
      return true;
    }

    step() {
      return 1;
    }

    embody() {
      var x, y;
      if (this.props.interior) {
        return;
      }
      this.bodyDef = new box2d.b2BodyDef();
      this.bodyDef.type = box2d.b2BodyType.b2_staticBody;
      x = ((this.props.x + .5) * 64) / gg.scaling;
      y = ((this.props.y + .5) * 64) / gg.scaling;
      this.bodyDef.position.Set(x, y);
      this.polygonShape = new box2d.b2PolygonShape;
      this.polygonShape.SetAsBox(32 / gg.scaling, 32 / gg.scaling);
      this.fixtureDef = new box2d.b2FixtureDef;
      this.fixtureDef.shape = this.polygonShape;
      this.fixtureDef.filter.categoryBits = gg.masks.solid;
      this.fixtureDef.filter.maskBits = -1;
      this.body = gg.world.CreateBody(this.bodyDef);
      this.body.CreateFixture(this.fixtureDef);
      return true;
    }

  };

}).call(this);
