// Generated by CoffeeScript 2.3.0
(function() {
  // used to keep the pls constant
  var __Light_Manager;

  __Light_Manager = function(T = 'PointLight') {
    var NUM, o;
    NUM = gg.mobile ? 5 : 8;
    gg.bubble(`Light Manager &lt;${T}&gt; ( ${NUM} )`);
    o = {
      pool: [],
      _pooled: 0,
      lights: [],
      blacks: [],
      first: function() {
        var j, l, ref1;
        console.log(`Light Manager <${T}>`);
        for (j = 1, ref1 = NUM; (1 <= ref1 ? j <= ref1 : j >= ref1); 1 <= ref1 ? j++ : j--) {
          l = new THREE.PointLight(0x000000, 0, 0);
          l.position.z = -5000;
          this.blacks.push(l);
        }
        return 1;
      },
      register: function(l) {
        this.pool.unshift(l);
        this.process();
        return 0;
      },
      process: function() { // also processes
        var _filter, _sort, array, j, k, l, len, len1, pool, ref1;
        ref1 = this.pool;
        for (j = 0, len = ref1.length; j < len; j++) {
          l = ref1[j];
          gg.scene.remove(l);
        }
        _sort = function(a, b) {
          var c, d;
          c = a.position.clone().distanceToSquared(gg.camera.position.clone());
          d = b.position.clone().distanceToSquared(gg.camera.position.clone());
          return c - d;
        };
        _filter = function(pl) {
          var interiormatch, nointerior, r, v, visible;
          v = pl._visual;
          r = v.props;
          interiormatch = (gg.interior != null) && gg.interior.name === r.interior;
          nointerior = (gg.interior == null) && (r.interior == null);
          visible = interiormatch || nointerior;
          return visible;
        };
        pool = this.pool.slice(0);
        pool = pool.filter(_filter);
        pool = pool.concat(this.blacks);
        pool.sort(_sort);
        // gg.scene.remove l for l in pool
        array = pool.slice(0, NUM);
        for (k = 0, len1 = array.length; k < len1; k++) {
          l = array[k];
          gg.scene.add(l);
        }
        this.lights = array;
        this._pooled = `${this.pool.length} of ${NUM} max`;
        return 1;
      },
      checkoff: function(l) {
        this.pool.splice(this.pool.indexOf(l), 1);
        this.process();
        return 0;
      }
    };
    o.first();
    return o;
  };

  gg.Map = class Map {
    constructor() {
      var i, j;
      this.mesh = new THREE.Mesh();
      this.meshes = []; // for lb
      this.copy = [];
      this.chunks = [];
      for (i = j = 0; j <= 4; i = ++j) {
        this.chunks[i] = [null, null, null, null, null];
      }
      this.build = false;
      this.actives = [];
      this.offChunks = [];
      this.load = false;
      gg.lightmanager = __Light_Manager();
    }

    getNosj() {
      var self;
      $.ajaxSetup({
        'async': false
      });
      self = this;
      $.getJSON("sons/nosj.json", function(data) {
        return self.nosj = data;
      });
      return true;
    }

    /*
    used to initially collect all nosj.json elements into chunks
    */
    chunkify() {
      var c, j, len, r, ref, x, xy, y;
      ref = this.nosj.visuals;
      CAT: //;
      for (j = 0, len = ref.length; j < len; j++) {
        r = ref[j];
        switch (r.type) {
          case 'Pickup':
            console.log('its a pu');
            if (gg.ed == null) {
              continue CAT;
            }
            break;
          case 'Block':
          case 'Surface':
          case 'Light':
          case 'Door':
          case 'Neon':
            x = Math.floor(r.x / gg.C.CHUNKSPAN);
            y = Math.floor(r.y / gg.C.CHUNKSPAN);
            break;
          default:
            x = Math.floor((r.x / 64) / gg.C.CHUNKSPAN);
            y = Math.floor((r.y / 64) / gg.C.CHUNKSPAN);
        }
        xy = `${x},${y}`;
        c = this.offChunks[xy] || (this.offChunks[xy] = new gg.Chunk(x, y));
        c.addr(r);
        if (gg.DEV) {
          gg.idpoolforprops(r);
        }
      }
      // ch.post() for i, ch of @offChunks
      return true;
    }

    chunkCheck() {
      var d, diff, n;
      // return unless gg.ply?
      gg.lightmanager.process();
      n = this.n = {};
      n.x = Math.floor(gg.x / gg.C.CHUNITS);
      n.y = Math.floor(gg.y / gg.C.CHUNITS);
      d = {};
      d.x = gg.CURCHUNK[0] - n.x;
      d.y = -(gg.CURCHUNK[1] - n.y);
      diff = d.x || d.y;
      if (this.load && !diff) {
        return;
      }
      gg.CURCHUNK[0] = n.x;
      gg.CURCHUNK[1] = n.y;
      if (diff || !this.load) {
        this.shift(n, d);
      }
      this.load = true;
      return true;
    }

    prepare() {
      var i, j, k;
      for (i = j = 0; j <= 4; i = ++j) {
        this.copy[i] = this.chunks[i].slice(0);
      }
      for (i = k = 0; k <= 4; i = ++k) {
        this.chunks[i] = [null, null, null, null, null];
      }
      return true;
    }

    shift(n, d) {
      var a, c, j, k, r, v, x, xy, y;
      // console.log('shift')
      this.actives = [];
      this.prepare();
      for (y = j = 0; j <= 4; y = ++j) {
        for (x = k = 0; k <= 4; x = ++k) {
          r = {};
          r.x = gg.C.CTABLE[y][x][0] + n.x;
          r.y = gg.C.CTABLE[y][x][1] + n.y;
          xy = `${r.x},${r.y}`;
          v = gg.Map.v = {
            x: x - d.x,
            y: y - d.y
          };
          if (v.x >= 0 && v.y >= 0 && v.x < 5 && v.y < 5) {
            // console.log "#{x},#{y} > #{v.x},#{v.y}"
            c = this.chunks[y][x] = this.copy[v.y][v.x] || null;
            a = this.copy[y][x] || null;
            if (c) {
              this.actives.push(c);
            }
            if (a && (a.x > n.x + 2 || a.x < n.x - 2 || a.y > n.y + 2 || a.y < n.y - 2)) {
              // console.log "#{x},y falls out of bounds"
              a.disappear();
            } else if (!c && (x > 0 && x < 4 && y > 0 && y < 4)) {
              // console.log "free spot #{x},#{y}"
              a = this.chunks[y][x] = this.offChunks[xy] || null;
              if (a) {
                a.show();
                this.actives.push(a);
              }
            }
          }
        }
      }
      this.relit();
      if (gg.ed != null) {
        this.mesheseru();
      }
      if (gg.minimap != null) {
        gg.minimap.build();
      }
      if (gg.ed != null) {
        gg.map.cyancubes();
        gg.map.plaster();
      }
      return true;
    }

    relit() {
      var x, y;
      gg.renderer.shadowMap.needsUpdate = true;
      x = gg.CURCHUNK[0] + .5 * gg.C.CHUNITS;
      y = gg.CURCHUNK[1] + .5 * gg.C.CHUNITS;
      gg.moon.position.set(x, y, 300);
      gg.moon.target.position.set(x + 96, y - 96, 0);
      // gg.moon.shadow.camera.position.copy gg.moon.position
      return 1;
    }

    step() {
      var c, i, j, k, len, len1, len2, m, ref1, ref2, ref3, ref4, ref5, t, v;
      if ((ref1 = gg.ply) != null) {
        if (typeof ref1.steps === "function") {
          ref1.steps();
        }
      }
      if (gg.keys[69] === 1) { // e
        gg.net.out.USE = 1;
      }
      if (gg.minimap != null) {
        gg.minimap.chase();
      }
      ref2 = this.actives;
      for (j = 0, len = ref2.length; j < len; j++) {
        c = ref2[j];
        ref3 = c.visuals;
        for (k = 0, len1 = ref3.length; k < len1; k++) {
          v = ref3[k];
          v.step();
        }
      }
      if (gg.net != null) {
        ref4 = gg.net.visuals;
        for (i in ref4) {
          v = ref4[i];
          v.step();
        }
        gg.net.in = {};
      }
      ref5 = gg.trails;
      for (m = 0, len2 = ref5.length; m < len2; m++) {
        t = ref5[m];
        if (t != null) {
          t.step();
        }
      }
      return true;
    }

    dtor(deep) {
      var c, i, j, k, len, ref1;
      ref1 = this.actives;
      for (j = 0, len = ref1.length; j < len; j++) {
        c = ref1[j];
        c.disappear(deep);
      }
      this.copy = [];
      for (i = k = 0; k <= 4; i = ++k) {
        this.chunks[i] = [null, null, null, null, null];
      }
      this.load = false;
      return true;
    }

    mesheseru() {
      var a, j, k, len, len1, ref1, ref2, v;
      console.log('Meshes-seru!');
      // Ugly loop for Ed, blegh!
      if (gg.ed != null) {
        this.meshes = [];
        ref1 = this.actives;
        for (j = 0, len = ref1.length; j < len; j++) {
          a = ref1[j];
          ref2 = a.visuals;
          for (k = 0, len1 = ref2.length; k < len1; k++) {
            v = ref2[k];
            if (v.mesh) {
              this.meshes.push(v.mesh);
            }
          }
        }
      }
      return 1;
    }

  };

}).call(this);
