// Generated by CoffeeScript 2.3.0
(function() {
  var ATM, Activator, Block, BlueGloves, Cable, Car, CarDoor, Casing, Chunk, Decal, Door, Drive, Dumpster, Entity, Generator, Gun, Hands, IRCNAME, Incubator, Interior, Item, LabFreezer, Melee, Mob, ParkingSpace, Pedestrian, Pickup, Player, Routine, SafeZone, Session, TakeABreak, Teleporter, Terminal, VacuumOven, VendingMachine, Vendor, Visual, Walk, WebSocketServer, Worklight, box2d, colors, fs, gta, pad, random, zeroorone,
    indexOf = [].indexOf;

  fs = require('fs');

  colors = require('colors');

  box2d = require('box2dweb');

  WebSocketServer = require('ws').Server;

  Math.hypot = Math.hypot || function() {
    var i, length, m, ref, y;
    y = 0;
    length = arguments.length;
    for (i = m = 0, ref = length - 1; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {
      if (arguments[i] === 2e308 || arguments[i] === -2e308) {
        return 2e308;
      }
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

  random = function(a) {
    return a[Math.floor(Math.random() * a.length)];
  };

  gta = global.gta = {
    id: 1,
    sessions: [],
    chunks: {},
    hashes: [],
    raws: {},
    frame: 0, // -9007199254740992
    ping: 100,
    reduce: 2,
    chunksize: 5,
    scaling: 14,
    stats: {
      bytesin: 0,
      bytesout: 0
    },
    nosj: JSON.parse(fs.readFileSync('../sons/nosj.json', 'utf8')),
    cars: JSON.parse(fs.readFileSync('../sons/cars.json', 'utf8')),
    weps: JSON.parse(fs.readFileSync('../sons/weps.json', 'utf8')),
    items: JSON.parse(fs.readFileSync('../sons/items.json', 'utf8')),
    activators: JSON.parse(fs.readFileSync('../sons/activators.json', 'utf8')),
    surround: [[[-2, 2], [-1, 2], [0, 2], [1, 2], [2, 2]], [[-2, 1], [-1, 1], [0, 1], [1, 1], [2, 1]], [[-2, 0], [-1, 0], [0, 0], [1, 0], [2, 0]], [[-2, -1], [-1, -1], [0, -1], [1, -1], [2, -1]], [[-2, -2], [-1, -2], [0, -2], [1, -2], [2, -2]]],
    timestep: 1.0 / 60.0,
    world: null,
    intrs: [],
    walks: [],
    walksbych: {},
    drives: [],
    entities: [],
    entitiesbych: {},
    parkingspaces: [],
    parkingspacesbych: {},
    nearestparkingspacesbych: [],
    pickuppool: -1,
    decalpool: 0,
    activatorpool: 0,
    globalbubbles: [],
    masks: {
      none: 0x0000,
      solid: 0x0001,
      organic: 0x0002,
      items: 0x0004,
      introrganic: 0x0008,
      intrsolid: 0x00016,
      intritems: 0x00032
    },
    DEGTORAD: 0.0174532925199432957,
    RADTODEG: 57.295779513082320876,
    drops: {
      Makeshift: ['Shank', 'Kitchen Knife'],
      Common: ['Combat Knife', 'M9', 'FN 57', 'Compact 45', 'M1911', 'MP412 REX', 'UMP', 'AK-12', 'Mare\'s Leg'],
      Uncommon: ['Machete', 'SPAS-12', 'G36C', 'M4A1', 'AN-94', '.44 Magnum', 'SKS', 'Scout Elite'],
      Mediumrare: ['Carbon Knife', 'Desert Eagle', 'HK416', 'M16A4', 'AEK-971', 'SCAR-H', 'SVD-12', 'Mk 11', 'M40A5'],
      Rare: ['Dragon Knife', 'AS Val', 'RPG', 'Intervention']
    },
    chances: [
      24,
      36,
      20,
      14,
      6 // adds up to 100
    ],
    colors: {
      Makeshift: 'smokewhite',
      Common: 'smokewhite', // '#8897FF' # blue
      Uncommon: '#D8D795', // yellowish
      Mediumrare: '#8897FF', // blue #BD64E2' # pink
      Rare: '#B25EFF' // purple
    },
    foods: ['Water bottle', 'Canned beans', 'Cabbage', 'Soda']
  };

  gta.hz = 1000 / gta.ping;

  gta.chunklife = 60000 / gta.ping / 4;

  gta.chunkunits = gta.chunksize * 64;

  console.log('');

  console.log("     -~=. GTA2.0 Node.js server .=~-".green);

  console.log(`       server runs at ${gta.hz} Hz / ${gta.ping} ms`.cyan);

  console.log('');

  IRCNAME = Math.random().toString(36).substring(7); // .replace '.', ''

  gta.start = function() {
    var gravity, listener, wss;
    gta.timer();
    gta.weighted = gta.weigh(gta.chances, Object.keys(gta.drops));
    gta.chunkify();
    console.log('making server');
    wss = new WebSocketServer({
      port: 8887
    });
    gravity = new box2d.Common.Math.b2Vec2(0, 0);
    gta.world = new box2d.Dynamics.b2World(gravity, false);
    listener = new box2d.Dynamics.b2ContactListener;
    listener.BeginContact = function(contact) {
      var a, b;
      a = contact.GetFixtureA().GetBody().GetUserData();
      b = contact.GetFixtureB().GetBody().GetUserData();
      if (!((a != null) && (b != null))) {
        return;
      }
      a.beginContact(b);
    };
    listener.PostSolve = function(contact, impulse) {
      var a, b, n;
      a = contact.GetFixtureA().GetBody().GetUserData();
      b = contact.GetFixtureB().GetBody().GetUserData();
      n = impulse.normalImpulses[0];
      a.postSolve(b, n);
    };
    gta.world.SetContactListener(listener);
    true;
    wss.on('connection', function(ws) {
      var id, ses;
      id = gta.id++;
      ses = new Session(id, ws);
      gta.sessions.push(ses);
      ws.on('message', function(message) {
        return ses.read(message);
      });
      ws.on('close', function() {
        var i;
        ses.close();
        i = gta.sessions.indexOf(ses);
        return gta.sessions.splice(i, 1);
      });
      ws.send(JSON.stringify([
        {
          YOURE: id
        }
      ]));
      return true;
    });
    setInterval(gta.loop, gta.ping);
    setInterval(gta.worldstep, gta.timestep * 1000);
    setInterval(gta.timer, 1000);
    return true;
  };

  pad = function(v, w) {
    while (v.length < w) {
      v = `0${v}`;
    }
    return v;
  };

  zeroorone = function(bool) {
    if (bool) {
      return 1;
    } else {
      return 0;
    }
  };

  gta.timer = function() {
    var c, chunks, frame, i, io, oi, players, ref, ref1, size, sleeping, visuals;
    size = gta.sessions.filter(function(v) {
      return v !== void 0;
    }).length; // fancy array length ?
    players = pad(`${size}`, 2);
    io = pad(`${gta.stats.bytesin / 1000}`, 3);
    oi = pad(`${gta.stats.bytesout / 1000}`, 3);
    frame = pad(`${gta.frame}`, 5); // 16
    chunks = Object.keys(gta.chunks).length;
    visuals = 0;
    ref = gta.chunks;
    for (i in ref) {
      c = ref[i];
      visuals += c.visuals.length;
    }
    sleeping = 0;
    ref1 = gta.chunks;
    for (i in ref1) {
      c = ref1[i];
      if (c.sleeping) {
        sleeping += 1;
      }
    }
    process.title = `players: ${players}, in: ${io} KB/sec, out: ${oi} KB/sec`;
    process.title += ` frame: ${frame}, chunks: ${chunks}(${sleeping})`;
    process.title += `, visuals: ${visuals}`;
    gta.stats.bytesin = 0.0;
    gta.stats.bytesout = 0.0;
    /*for ses in gta.sessions
    		kb = ses.outed / 1000
    		if not ses.megabyte and kb > 500
    ses.megabyte = true*/
    return true;
  };

  gta.worldstep = function() {
    gta.world.Step(1 / 60, 3, 2);
    // gta.world.ClearForces()
    return true;
  };

  gta.loop = function() {
    var a, c, i, json, len, m, o, ref, ref1, ref2, ref3, ref4, ref5, ses;
    ref = gta.chunks;
    for (i in ref) {
      c = ref[i];
      if (!c.step()) {
        delete gta.chunks[i];
      }
    }
    ref1 = gta.chunks;
    for (i in ref1) {
      c = ref1[i];
      c.observed = false;
      c.firststep = false;
    }
    ref2 = gta.intrs;
    for (i in ref2) {
      o = ref2[i];
      if (!o.step()) {
        delete gta.intrs[i];
      }
    }
    ref3 = gta.chunks;
    for (i in ref3) {
      c = ref3[i];
      c.compile();
    }
    ref4 = gta.sessions;
    for (i = m = 0, len = ref4.length; m < len; i = ++m) {
      ses = ref4[i];
      ses.step();
      a = ses.pack();
      if (!a.length) {
        continue;
      }
      json = JSON.stringify(a);
      ses.send(json);
    }
    ref5 = gta.chunks;
    for (i in ref5) {
      c = ref5[i];
      c.after();
    }
    gta.globalbubbles = [];
    gta.frame = gta.frame + 1 === 9007199254740992 ? 0 : gta.frame + 1;
    return true;
  };

  gta.chunkify = function() {
    var c, hash, len, m, r, ref, x, y;
    ref = this.nosj.visuals;
    for (m = 0, len = ref.length; m < len; m++) {
      r = ref[m];
      switch (r.type) {
        case 'Entity':
        case 'Walk':
        case 'Drive':
        case 'Parking space':
        case 'Safe Zone':
          gta.factory(r);
          continue;
        case 'Light':
        case 'Decal':
        case 'Neon':
          continue;
        case 'Block':
        case 'Surface':
        case 'Door':
          x = Math.floor(r.x / gta.chunksize);
          y = Math.floor(r.y / gta.chunksize);
          break;
        default:
          x = Math.floor(r.x / gta.chunkunits);
          y = Math.floor(r.y / gta.chunkunits);
      }
      hash = `${x},${y}`;
      if (-1 === gta.hashes.indexOf(hash)) {
        gta.hashes.push(hash);
      }
      c = this.raws[hash] || (this.raws[hash] = []);
      gta.idpoolofprops(r);
      c.push(r);
    }
    console.log(`lowest activator is ${Activator.prototype.idpool}`);
    gta.parkingspacespass();
    gta.walkspass();
    gta.safezonespass();
    return true;
  };

  gta.idpoolofprops = function(props) {
    if (gta.activators[props.type]) {
      Activator.prototype.idpool = Math.min(Activator.prototype.idpool, props.id);
    }
    return 1;
  };

  gta.factory = function(props) {
    switch (props.type) {
      // in nosj
      case 'Block':
      case 'Surface':
        return new Block(props);
      case 'Door':
        return new Door(props);
      case 'Entity':
        return new Entity(props);
      case 'Walk':
        return new Walk(props);
      case 'Drive':
        return new Drive(props);
      case 'Parking space':
        return new ParkingSpace(props);
      case 'Safe Zone':
        return new SafeZone(props);
      case 'Table':
        return new Activator(props);
      case 'Desk':
        return new Activator(props);
      case 'Chair':
        return new Activator(props);
      case 'Couch':
        return new Activator(props);
      // Activators
      case 'Lab Freezer':
        return new LabFreezer(props);
      case 'Vacuum Oven':
        return new VacuumOven(props);
      case 'Incubator':
        return new Incubator(props);
      case 'Generator':
        return new Generator(props);
      case 'Worklight':
        return new Worklight(props);
      case 'Terminal':
        return new Terminal(props);
      case 'Teleporter':
        return new Teleporter(props);
      // civil Activators
      case 'ATM':
        return new ATM(props);
      case 'Vending Machine':
        return new VendingMachine(props);
      // containers
      case 'Dumpster':
        return new Dumpster(props);
      case 'Pickup':
        return new Pickup(props);
      case 'M9':
      case 'M1911':
      case 'MP412 REX':
      case 'FN 57':
      case 'Compact 45':
      case '.44 Magnum':
      case 'Desert Eagle':
      case 'JS2':
      case 'UMP':
      case 'Groza-1':
      case 'Groza-4':
      case 'Magpul PDR':
      case 'G36C':
      case 'M4A1':
      case 'AS Val':
      case 'AK-12':
      case 'AN-94':
      case 'AEK-971':
      case 'HK416':
      case 'M16A4':
      case 'SCAR-H':
      case 'Mare\'s Leg':
      case 'SPAS-12':
      case 'SKS':
      case 'SVD-12':
      case 'Mk 11':
      case 'Scout Elite':
      case 'M40A5':
      case 'Intervention':
      case 'RPG':
        return new Pickup(props);
      case 'Shank':
      case 'Kitchen Knife':
      case 'Combat Knife':
      case 'Carbon Knife':
      case 'Machete':
      case 'Dragon Knife':
        return new Pickup(props);
      default:
        return console.error(`unknown visual type \`${props.type}\``);
    }
  };

  gta.factoryy = function(props) {
    switch (props.model) {
      case 'M9':
      case 'M1911':
      case 'MP412 REX':
      case 'FN 57':
      case 'Compact 45':
      case '.44 Magnum':
      case 'Desert Eagle':
      case 'JS2':
      case 'UMP':
      case 'Groza-1':
      case 'Groza-4':
      case 'Magpul PDR':
      case 'G36C':
      case 'M4A1':
      case 'AS Val':
      case 'AK-12':
      case 'AN-94':
      case 'AEK-971':
      case 'HK416':
      case 'M16A4':
      case 'SCAR-H':
      case 'Mare\'s Leg':
      case 'SPAS-12':
      case 'SKS':
      case 'SVD-12':
      case 'Mk 11':
      case 'Scout Elite':
      case 'M40A5':
      case 'Intervention':
      case 'RPG':
        return new Gun(props, gta.weps[props.model]);
      case 'Shank':
      case 'Kitchen Knife':
      case 'Combat Knife':
      case 'Carbon Knife':
      case 'Machete':
      case 'Dragon Knife':
        return new Melee(props, gta.weps[props.model]);
      case 'Hands':
        return new Hands(props);
      case 'Blue gloves':
        return new BlueGloves(props);
      default:
        return console.error(`unknown pickup type \`${props.type}\``);
    }
  };

  gta.weigh = function(weights, array) {
    var cur, i, m, ref, weigh;
    weigh = {
      weighted: [],
      total: eval(weights.join('+')),
      produce: function() {
        return this.weighted[Math.floor(Math.random() * this.total)];
      }
    };
    cur = 0;
    while (cur < array.length) {
      for (i = m = 0, ref = weights[cur] - 1; (0 <= ref ? m <= ref : m >= ref); i = 0 <= ref ? ++m : --m) {
        weigh.weighted[weigh.weighted.length] = array[cur];
      }
      cur++;
    }
    return weigh;
  };

  gta.drop = function(from, reroll) {
    return;
    // return unless from.type is 'Zombie'

    // rarity = gta.weighted.produce()
    // array = gta.drops[rarity]
    // i = Math.floor Math.random() * array.length
    // item = array[i]

    // console.log "dropping #{rarity} item: `#{item}`"

    // props = model: item, x: from.props.x, y: from.props.y, z: 64# , rarity: rarity
    // new Pickup props
    return true;
  };

  gta.loot = function(from) {
    return true;
  };

  gta.parkingspacespass = function() {
    var ch, h, i, len, m, nearest, p, ref, ref1, results;
    console.log('parkingspacespass');
    ref = gta.hashes;
    results = [];
    for (m = 0, len = ref.length; m < len; m++) {
      h = ref[m];
      ch = h.split(',');
      nearest = gta.nearestparkingspacesbych[h] = [];
      ref1 = gta.parkingspaces;
      for (i in ref1) {
        p = ref1[i];
        nearest.push({
          v: p,
          range: Math.hypot(ch[0] * gta.chunkunits - p.props.x, ch[1] * gta.chunkunits - p.props.y)
        });
      }
      results.push(nearest.sort(function(a, b) {
        if (a.range < b.range) {
          return -1;
        } else {
          return 1;
        }
      }));
    }
    return results;
  };

  // console.log a.range for nearest
  gta.walkspass = function() {
    var i, ref, w;
    ref = gta.walks;
    for (i in ref) {
      w = ref[i];
      w.preprocess();
    }
    console.log(`walkspass preprocessed ${gta.walks.length}*${gta.walks.length} walks`);
    return 0;
  };

  gta.safezonespass = function() {
    var i, ref, s;
    ref = gta.safezones;
    for (i in ref) {
      s = ref[i];
      s.preprocess();
    }
    console.log("safezonespass");
    return 0;
  };

  Session = class Session {
    constructor(id1, ws1) {
      var len, m, ref, ses;
      this.id = id1;
      this.ws = ws1;
      console.log(`accepted ply #${this.id}`);
      this.in = {};
      this.out = {};
      this.bubbles = [];
      this.take = -1;
      this.outed = 0;
      this.last = Date.now();
      this.delta = 0;
      this.removes = [];
      this.visuals = [];
      this.ply = new Player(this);
      this.bubbles.push(`${gta.sessions.length} players on server`);
      ref = gta.sessions;
      // @bubbles.push "GTA2.0 Open Alpha"
      for (m = 0, len = ref.length; m < len; m++) {
        ses = ref[m];
        ses.bubbles.push('Player joined our world. Diablo\'s minions grow stronger.');
      }
    }

    read(text) {
      var c, driving, len, m, obj, ref, ref1;
      if (this.ply.dead) {
        return;
      }
      this.delta = Date.now() - this.last;
      this.last = Date.now();
      gta.stats.bytesin += Buffer.byteLength(text);
      obj = JSON.parse(text);
      if (parseFloat(obj[0] === (0/0) || parseFloat(obj[1] === (0/0) || parseFloat(obj[2] === (0/0) || parseFloat(obj[3] === (0/0)))))) {
        console.log('in coords has NaN'.yellow);
        return;
      }
      if (obj[4] != null) {
        this.in = obj[4];
      }
      // console.log "debug : @in.CAR " if @in.CAR?
      driving = (this.ply.car != null) && !this.ply.passenger;
      if (this.in.CAR == null) {
        this.ply.pose(obj);
      }
      if (driving) {
        if ((ref = this.ply.car) != null) {
          ref.pose(this.in.CAR || obj);
        }
      }
      this.visuals = [];
      ref1 = this.ply.chunks;
      for (m = 0, len = ref1.length; m < len; m++) {
        c = ref1[m];
        this.visuals = this.visuals.concat(c.visuals);
      }
      this.passive();
      this.action();
      this.take = gta.frame;
      return true;
    }

    step() {
      var a, cb, ref;
      if ((ref = this.mission) != null) {
        ref.step();
      }
      // return
      if ((this.ply.at != null) && (this.mission == null) && !this.t) {
        a = this;
        cb = function() {
          console.log(a.id);
          if (a.closed) {
            return;
          }
          a.mission = new gta.missions.Hotline(a);
          a.t = 0;
        };
        this.t = setTimeout(cb, 7000);
      }
      return 0;
    }

    passive() {
      var c, id, ignores, range, ref, ref1, t, u, x, y;
      ignores = [];
      ref = this.ply.cards;
      for (id in ref) {
        c = ref[id];
        ignores.push(c.v);
      }
      CAT: //;
      if (u = this.ply.find('Pickup', this.visuals, 0, 15, false, ignores)) {
        if (this.ply.cards[u.id] != null) {
          break CAT;
        }
        if (this.out.CARDS == null) {
          this.out.CARDS = [];
        }
        this.ply.cards[u.id] = {
          v: u,
          time: Date.now()
        };
        this.out.CARDS.push({
          id: u.id,
          name: u.props.model
        });
      }
      t = Date.now();
      ref1 = this.ply.cards;
      for (id in ref1) {
        c = ref1[id];
        x = Math.abs(c.v.props.x - this.ply.props.x);
        y = Math.abs(c.v.props.y - this.ply.props.y);
        range = Math.hypot(x, y);
        if (range <= 35) {
          c.time = t;
        } else {
          if (!(c.time < t - 2000)) {
            continue;
          }
          if (this.out.RMCARDS == null) {
            this.out.RMCARDS = [];
          }
          this.out.RMCARDS.push(id);
          delete this.ply.cards[id];
        }
      }
      return 0;
    }

    action() {
      var Activator, at, c, car, cardoor, cardoors, cars, container, door, filter, i1, intr, j1, len, len1, len2, len3, m, mob, people, ply, q, ref, ref1, ref2, to, u, xx, yy, z;
      // if @take is gta.frame
      // console.log "we already taken for this frame. ignoring".red
      if ((this.in.BLEH != null) && (this.ply.car != null)) { // weve-shut-the-door thing
        at = this.ply.at;
        this.ply.at.withdraw(this.ply);
        
        // this fixes ch.beyond
        this.ply.at = at;
        car = this.ply.car;
        car.acknowledged = true;
        car.state('l', 1);
      }
      
      if ((this.in.USE != null) && this.take !== gta.frame) {
        // The Finding
        cars = this.visuals.filter(function(v) {
          return 'Car' === v.type;
        });
        cardoors = [];
        for (m = 0, len = cars.length; m < len; m++) {
          c = cars[m];
          cardoors = cardoors.concat(c.doors);
        }
        // console.log "we collected #{cardoors.length} car doors"
        CAT: //;
        if (cardoor = this.ply.find('Car door', cardoors, 8, 12)) {
          car = cardoor.car;
          if (cardoor.seat != null) {
            this.bubbles.push('Someone\'s sitting here');
            break CAT;
          }
          if ((car.owner != null) && car.owner !== this.ply) {
            this.bubbles.push('It\'s locked');
            break CAT;
          }
          if (car.props.owners != null) {
            this.bubbles.push(`It\'s locked, it seems to belong to ${car.props.owners}`);
            break CAT;
          }
          gta.world.DestroyBody(this.ply.body);
          people = (car.doors.slice(0).filter(function(e) {
            return e.seat != null;
          })).length;
          cardoor.seat = this.ply;
          this.ply.cardoor = cardoor;
          this.ply.passenger = cardoor.index > 0;
          car.enter(this.ply);
          if (people) {
            this.bubbles.push(`(There are ${people} others in this car.)`);
          }
          this.ply.state('yc', {
            i: car.id,
            r: car.props.r,
            f: 'right' === cardoor.door.side
          });
          xx = parseFloat(cardoor.props.xx.toFixed(gta.reduce));
          yy = parseFloat(cardoor.props.yy.toFixed(gta.reduce));
          this.ply.state('cd', {
            i: parseInt(cardoor.index),
            xx: xx,
            yy: yy
          });
          // at = @ply.at
          // @ply.at.withdraw @ply

          // this fixes ch.beyond
          // @ply.at = at
          this.ply.hidden = true;
        } else if (door = this.ply.find('Door', this.visuals, 8, 15, true)) {
          to = door.vjson.to;
          // Enter Interior
          if (this.ply.props.interior == null) {
            intr = gta.intrs[to] || new Interior(to);
            this.out.INTR = to;
            this.out.INTRSTYLE = door.vjson.style;
            this.ply.props.interior = to;
            filter = this.ply.fixture.GetFilterData();
            filter.categoryBits = gta.masks.introrganic;
            filter.maskBits = gta.masks.intrsolid | gta.masks.introrganic;
            this.ply.fixture.SetFilterData(filter);
            this.ply.state('intr', 1);
            this.ply.intrstamp = gta.frame;
            ref = this.ply.at.subscribers;
            for (z = 0, len1 = ref.length; z < len1; z++) {
              ply = ref[z];
              if (ply.props.interior !== to) {
                ply.ses.removes.push(this.ply.id);
              }
            }
            ref1 = this.ply.chunks;
            for (i1 = 0, len2 = ref1.length; i1 < len2; i1++) {
              c = ref1[i1];
              c.unsubscribe(this.ply);
            }
            this.ply.chunks = [];
            this.ply.stamps = [];
            this.ply.at.withdraw(this.ply);
            door.displace(this.ply);
            this.out.TP = [this.ply.props.x, this.ply.props.y];
            this.ply.grid(this.ply.update());
            intr.occupants.push(this.ply);
            this.bubbles.push(`Entering ${to}`);
          // Exit Interior
          } else if (to === this.ply.props.interior) {
            intr = gta.intrs[to];
            intr.leave(this.ply);
            delete this.ply.props.interior;
            delete this.ply.states.intr;
            this.ply.intrstamp = -1;
            this.out.OUTR = 1;
            filter = this.ply.fixture.GetFilterData();
            filter.categoryBits = gta.masks.organic;
            filter.maskBits = gta.masks.solid | gta.masks.organic;
            this.ply.fixture.SetFilterData(filter);
            ref2 = this.ply.chunks;
            for (j1 = 0, len3 = ref2.length; j1 < len3; j1++) {
              c = ref2[j1];
              c.unsubscribe(this.ply);
            }
            this.ply.chunks = [];
            this.ply.stamps = [];
            this.ply.at.withdraw(this.ply);
            door.displace(this.ply, true);
            this.out.TP = [this.ply.props.x, this.ply.props.y];
            this.ply.grid(this.ply.update());
            this.bubbles.push(`Leaving ${door.vjson.style} ${to}, come again`);
          }
        } else if (Activator = this.ply.find('Activator', this.visuals, 8, 12)) {
          q = Activator.use();
          this.bubbles.push(q);
        } else if (container = this.ply.find('Container', this.visuals, 8, 16)) {
          q = container.use();
          this.bubbles.push(q);
        // show the item cards
        } else if (mob = this.ply.find('Mob', this.visuals, 8, 16)) {
          q = mob.use();
          if (mob.states.o === 2) {
            q = "Poncho man remains quiet";
          }
          this.bubbles.push(`${q}`);
        }
      }
      // end @in.USE / <ENTER> key
      if (this.in.CARD != null) {
        if (this.ply.cards[this.in.CARD] != null) {
          u = this.ply.cards[this.in.CARD].v;
          if (u.dtord === false) {
            this.ply.pickup(u);
            // u.at.withdraw u
            u.dtor(); // withdraws
          }
          console.log("nice");
          delete this.ply.cards[this.in.CARD];
        }
      }
      if (this.in.SEL != null) {
        if (this.ply.inventory[this.in.SEL] && this.ply.selected !== this.in.SEL) {
          this.ply.state('u', this.in.SEL);
          this.ply.selected = this.in.SEL;
          this.out.SEL = this.ply.selected;
          this.ply.items[this.ply.selected][0].select();
        }
      }
      
      // console.log "ses ##{@id} sels #{@in.SEL}"
      if ((this.in.EXITCAR != null) && (this.ply.car != null)) {
        // when exiting, gta2.0 sends last car pos as Object
        // @ply.car.pose @in.CAR if @in.CAR?
        cardoor = this.ply.cardoor;
        car = this.ply.car;
        this.ply.car.exit(this.ply);
        this.ply.car = null;
        this.ply.hidden = false;
        this.ply.props.r = car.props.r;
        this.ply.props.x = cardoor.props.x;
        this.ply.props.y = cardoor.props.y;
        this.ply.reduce();
        // @out.TP = [ @ply.props.x, @ply.props.y ]
        this.ply.at.putcheck(this.ply);
        this.ply.embody();
      }
      if (this.in.T != null) {
        if (this.take !== gta.frame) {
          this.ply.trigger();
        }
      }
      if (this.in.W != null) {
        this.ply.state('w', this.in.W); // walk
      }
      return true;
    }

    close() {
      var c, len, len1, m, ref, ref1, ref2, ref3, ses, z;
      if (this.mission != null) {
        this.mission.cleanup();
      }
      if ((ref = this.ply.car) != null) {
        ref.exit(this.ply);
      }
      ref1 = this.ply.chunks;
      for (m = 0, len = ref1.length; m < len; m++) {
        c = ref1[m];
        c.unsubscribe(this.ply);
      }
      if ((ref2 = this.ply.at) != null) {
        ref2.withdraw(this.ply);
      }
      if (this.ply.props.interior != null) {
        // @ply.die()
        gta.intrs[this.ply.props.interior].leave(this.ply);
      }
      this.ply.dtor();
      this.closed = true;
      ref3 = gta.sessions;
      for (z = 0, len1 = ref3.length; z < len1; z++) {
        ses = ref3[z];
        ses.bubbles.push('Player left');
      }
      return true;
    }

    send(text) {
      var bytes;
      bytes = Buffer.byteLength(text);
      gta.stats.bytesout += bytes;
      this.outed += bytes;
      this.ws.send(text);
      return 0;
    }

    pack() {
      var a, c, i, len, m, ref;
      a = [];
      ref = this.ply.chunks;
      for (i = m = 0, len = ref.length; m < len; i = ++m) {
        c = ref[i];
        c.observed = true;
        a = a.concat(c.pack(this.ply.stamps[i], this.ply.props.interior, this.ply.intrstamp));
        if (c.removes.length) {
          this.removes = this.removes.concat(c.removes);
        }
      }
      if (this.ply.inventorystamp === gta.frame) {
        // a = a.concat @ply.interior.pack @ply.intrstamp if @ply.interior?
        this.out.inventory = this.ply.inventory;
      }
      if (this.removes.length) {
        this.out.removes = this.removes;
      }
      this.removes = [];
      this.bubbles = this.bubbles.concat(gta.globalbubbles);
      if (this.bubbles.length) {
        this.out.bubbles = this.bubbles;
      }
      this.bubbles = [];
      if (!!Object.keys(this.out).length) {
        // @out.f = gta.frame
        a.unshift(this.out);
      }
      a = a.filter(function(e) {
        return e; // remove falsy / nulls 
      });
      this.in = {};
      this.out = {};
      return a;
    }

  };

  gta.chart = function(x, y) {
    var hash;
    hash = `${x},${y}`;
    return gta.chunks[hash] || new Chunk(x, y);
  };

  Visual = class Visual {
    constructor(props1) {
      var ref;
      this.props = props1;
      if (this.props.x == null) {
        this.props.x = 0;
      }
      if (this.props.y == null) {
        this.props.y = 0;
      }
      if (this.props.r == null) {
        this.props.r = 0;
      }
      if (this.props.z == null) {
        this.props.z = 64;
      }
      if (this.props.interior === null) { // imperative for sql vis
        delete this.props.interior;
      }
      this.type = 'Visual';
      this.id = "v0";
      this.at = null;
      this.states = {};
      this.statestamp = -1;
      this.before = {};
      this.reduced = {};
      this.before.reduced = {};
      this.served = false;
      this.stamp = gta.frame;
      this.hidden = false;
      this.volatile = false; // to dtor in step when unobserved
      this.dtord = false;
      
      this.vjson = ((ref = this.props.vjson) != null ? ref.length : void 0) ? JSON.parse(this.props.vjson) : {};
      if (this.props.interior != null) {
        // @interior = gta.intrs[ @props.interior ] or null
        this.state('intr', 1);
      }
    }

    
    // console.log "#{@type} is in #{@interior.name}" if @interior?
    state(i, v) {
      this.states[i] = v;
      this.statestamp = gta.frame;
      this.refresh();
      return true;
    }

    dtor() {
      var ref, withdrew;
      withdrew = (ref = this.at) != null ? ref.withdraw(this) : void 0;
      this.dtord = true;
      // console.log "withdrew a #{@type}" if withdrew
      return 0;
    }

    hit() {
      return 0;
    }

    whole() {
      if (this.props.static) {
        return null;
      }
      return [this.id, this.states, this.reduced.x, this.reduced.y, this.reduced.r, this.reduced.z];
    }

    pack() {
      var a;
      if (this.props.static) {
        return null;
      }
      a = [this.id];
      if (this.statestamp === gta.frame) {
        a[1] = this.states;
      }
      if (this.before.reduced.x !== this.reduced.x) {
        a[2] = this.reduced.x;
      }
      if (this.before.reduced.y !== this.reduced.y) {
        a[3] = this.reduced.y;
      }
      if (this.before.reduced.r !== this.reduced.r) {
        a[4] = this.reduced.r;
      }
      if (this.before.reduced.z !== this.reduced.z) {
        a[5] = this.reduced.z;
      }
      this.before = JSON.parse(JSON.stringify(this.props));
      this.before.reduced = JSON.parse(JSON.stringify(this.reduced));
      return a;
    }

    step() {
      var ref;
      if (this.volatile && !((ref = this.at) != null ? ref.observed : void 0)) {
        console.log('dtoring volatile');
        this.dtor();
      }
      /*if @props.interior? and not gta.intrs[@props.interior]?
      return false
      		else
      return true*/
      return 0;
    }

    after() {
      return 'before';
    }

    refresh() {
      var ref;
      this.stamp = gta.frame;
      if ((ref = this.at) != null) {
        ref.sleeping = false;
      }
      return true;
    }

    collect() {
      return this.stamp === gta.frame;
    }

    reduce() {
      this.reduced = {
        x: parseFloat(this.props.x.toFixed(gta.reduce)),
        y: parseFloat(this.props.y.toFixed(gta.reduce)),
        r: parseFloat(this.props.r.toFixed(gta.reduce)),
        z: this.props.z
      };
      return true;
    }

    pose() {}

    update() {
      var travel;
      this.stamp = gta.frame;
      travel = this.rechunk();
      this.at.sleeping = false;
      return travel;
    }

    rechunk() {
      var cx, cy, len, m, moved, ply, ref, travel;
      cx = Math.floor(this.props.x / gta.chunkunits);
      cy = Math.floor(this.props.y / gta.chunkunits);
      travel = gta.chart(cx, cy);
      moved = this.at !== travel;
      // redesign out of bounds / ses.removes system
      if (moved) {
        this.served = false;
        if (this.at != null) {
          ref = this.at.subscribers;
          for (m = 0, len = ref.length; m < len; m++) {
            ply = ref[m];
            if (travel.beyond(ply.at)) {
              ply.ses.removes.push(this.id);
            }
          }
          // todo:
          // stacktrace: Mob.pose, Mob.Visual.update, Mob.Visual.rechunk, Chunk.beyond
          // rare crash where ply.at is null
          this.at.withdraw(this, true); // for first rechunk
        }
        this.at = travel;
        if (!this.hidden) {
          this.at.put(this);
        }
      }
      return {
        moved: moved,
        cx: cx,
        cy: cy
      };
    }

    find(target, visuals, reach, r, ethereal, ignores) {
      var filtered, len, m, probe, range, targets, v, x, y;
      targets = Array.isArray(target);
      filtered = visuals.filter(function(v) {
        var ref;
        if (targets) {
          return ref = v.type, indexOf.call(target, ref) >= 0;
        } else {
          return v.type === target;
        }
      });
      probe = {
        x: this.props.x,
        y: this.props.y
      };
      if (reach) {
        probe.x = probe.x + reach * Math.cos(this.props.r - (Math.PI / 2));
        probe.y = probe.y + reach * Math.sin(this.props.r - (Math.PI / 2));
      }
      for (m = 0, len = filtered.length; m < len; m++) {
        v = filtered[m];
        if (v === this) {
          continue;
        }
        if ((ignores != null) && ignores.indexOf(v) !== -1) {
          continue;
        }
        if (v.props.interior !== this.props.interior && !ethereal) {
          continue;
        }
        if (v.dead) { // lol
          continue;
        }
        x = Math.abs(v.props.x - probe.x);
        y = Math.abs(v.props.y - probe.y);
        range = Math.hypot(x, y);
        if (range <= r) {
          return v;
        }
      }
      return null;
    }

    beginContact(v) {
      // console.log "#{@id} touched #{v.id}"
      return 0;
    }

    postSolve(v, n) {
      // console.log "impulse is #{n}"
      return 0;
    }

  };

  Player = class Player extends Visual { // todo extends Mob / Man
    constructor(ses1) {
      var body, feet, hair, legs, s, skin, spawns;
      super({});
      this.ses = ses1;
      this.type = 'Player';
      this.id = `p${this.ses.id}`;
      this.cards = [];
      this.chunks = [];
      this.stamps = [];
      this.intrstamp = -1;
      this.statestamp = -1;
      this.car = null;
      this.inventory = {};
      this.inventorystamp = -1;
      this.items = {};
      this.selected = null;
      this.recoil = 0;
      this.health = 100;
      this.kill = false;
      this.dead = false;
      skin = ['wh', 'wh', 'wh', 'gl', 'bl'][Math.floor(Math.random() * 5)];
      feet = ['lo', 'sn', 'al', 'dr'][Math.floor(Math.random() * 4)];
      legs = ['je', 'de', 'kh'][Math.floor(Math.random() * 3)];
      body = ['po', 'sw', 'bo', 'pa', 'sh', 'co'][Math.floor(Math.random() * 6)];
      hair = ['br'][Math.floor(Math.random() * 1)];
      if (skin === 'bl') { // black men have black hair
        hair = 'Bl';
      }
      if (legs === 'kh' && feet === 'lo') { // dress shoes when trying loafers /w khaki (bad contrast in brown shoes/pants)
        feet = 'dr';
      }
      if (skin === 'bl' && body === 'po') { // become white when black /w poncho
        skin = 'gl';
      }
      if (body === 'po') { // poncho hood
        hair = 'ph';
      }
      if (body === 'po' && legs === 'kh') { // jeans when trying khaki /w poncho (its too brown)
        legs = 'je';
      }
      if (body === 'po' && feet === 'dr') { // sneakers when trying dress shoes /w poncho (dress shoes too nice for ponchoman)
        feet = 'sn';
      }
      this.state('o', `${skin}${feet}${legs}${body}${hair}`);
      this.ses.out.OUTFIT = this.states.o;
      this.parts = [];
      this.parts.push(skin, feet, legs, body, hair);
      this.pickup({
        props: {
          model: 'Hands'
        }
      });
      this.pickup({
        props: {
          model: 'Blue gloves'
        }
      });
      this.pickup({
        props: {
          model: 'M9'
        }
      });
      this.pickup({
        props: {
          model: 'UMP'
        }
      });
      this.pickup({
        props: {
          model: 'Magpul PDR'
        }
      });
      this.pickup({
        props: {
          model: 'AK-12'
        }
      });
      this.pickup({
        props: {
          model: 'Shank'
        }
      });
      spawns = [[-313, 594, -1.5, 67], [-522, 361, -4.7, 67], [-197, 492, -1.6, 67], [-243, 739, -1.0, 67], [-525, 728, -5.2, 67]];
      s = spawns[Math.floor(Math.random() * spawns.length)];
      this.pose([s[0], s[1], s[2], s[3]]);
      this.ses.out.TP = [this.props.x, this.props.y, this.props.z];
      // @grid @update()
      this.inventory['Hands']++;
      
      // @pickup props: type: 'JS2'
      setTimeout(() => {
        return this.state('scratch', 1);
      }, 500);
      this.embody();
    }

    // @reduce()
    dtor() {
      if (this.body != null) {
        if (this.body != null) {
          gta.world.DestroyBody(this.body);
        }
        this.body = null;
      }
      super.dtor();
      return 1;
    }

    embody() {
      var fd;
      this.bd = new box2d.Dynamics.b2BodyDef();
      this.bd.type = box2d.Dynamics.b2Body.b2_dynamicBody;
      //new box2d.b2Vec2 300 / gta.scaling, 300 / gta.scaling
      this.circleShape = new box2d.Collision.Shapes.b2CircleShape(10 / gta.scaling);
      fd = new box2d.Dynamics.b2FixtureDef;
      fd.shape = this.circleShape;
      fd.density = 1;
      fd.filter.categoryBits = gta.masks.organic;
      fd.filter.maskBits = gta.masks.solid | gta.masks.organic;
      this.bd.position.Set(this.props.x, this.props.y);
      this.body = gta.world.CreateBody(this.bd);
      this.body.SetUserData(this);
      this.fixture = this.body.CreateFixture(fd);
      return 1;
    }

    // override
    step() {
      super.step();
      if (this.recoil > 0) {
        this.recoil -= 0.075;
      }
      if (this.recoil < 0) {
        this.recoil = 0;
      }
      if (this.selected != null) {
        this.items[this.selected][0].step();
      }
      if (this.body != null) {
        this.body.SetPosition(new box2d.Common.Math.b2Vec2(this.props.x / gta.scaling, this.props.y / gta.scaling));
      }
      if (this.kill) {
        this.die();
      }
      return 1;
    }

    // override
    after() {
      delete this.states.g; // unshoot
      delete this.states.s; // unslash
      delete this.states.h; // unhit
      delete this.states.yc; // your car
      delete this.states.cd;
      delete this.states.scratch;
      return 1;
    }

    trigger() {
      var type;
      if (this.selected != null) {
        type = this.items[this.selected][0].type;
        if ((this.car != null) && (type === 'Gun' || type === 'Melee')) {
          return;
        }
        this.items[this.selected][0].use();
      }
      return 1;
    }

    pickup(r) {
      var has, item, name;
      r.props.type = 'Pickup';
      name = r.props.model;
      has = this.inventory[name] != null;
      item = gta.factoryy(r.props);
      item.owner = this;
      if (has) {
        this.inventory[name]++;
        this.items[name].push(item);
      } else {
        this.inventory[name] = 1;
        this.items[name] = [item];
      }
      this.inventorystamp = gta.frame;
      return 1;
    }

    // override
    whole() {
      return super.whole();
    }

    // override
    //pack: ->
    //a = super()

    //return a

    // override
    pose(o) {
      var con;
      if (o[0] != null) {
        this.props.x = o[0];
      }
      if (o[1] != null) {
        this.props.y = o[1];
      }
      if (o[2] != null) {
        this.props.r = o[2];
      }
      if (o[3] != null) {
        this.props.z = o[3];
      }
      this.reduce();
      con = this.before.reduced.x !== this.reduced.x || this.before.reduced.y !== this.reduced.y || this.before.reduced.r !== this.reduced.r || this.before.reduced.z !== this.reduced.z;
      if (!con) {
        return;
      }
      this.grid(this.update());
      return 0;
    }

    grid(travel) {
      var c, chart, i1, j1, len, len1, m, old, ref, sx, sy, v, x, y, z;
      if (travel.moved) {
        old = this.chunks.slice(0);
        this.chunks = [];
        this.stamps = [];
        for (y = m = 1; m <= 3; y = ++m) {
          for (x = z = 1; z <= 3; x = ++z) {
            sx = gta.surround[y][x][0] + travel.cx;
            sy = gta.surround[y][x][1] + travel.cy;
            chart = gta.chart(sx, sy);
            chart.observed = true;
            this.chunks.push(chart);
            chart.subscribe(this);
            this.stamps.push(old.indexOf(chart) === -1 ? gta.frame : -1);
          }
        }
        for (i1 = 0, len = old.length; i1 < len; i1++) {
          c = old[i1];
          if (this.chunks.indexOf(c) === -1) {
            c.unsubscribe(this);
            ref = c.visuals;
            for (j1 = 0, len1 = ref.length; j1 < len1; j1++) {
              v = ref[j1];
              this.ses.removes.push(v.id);
            }
          }
        }
      }
      // low-priority todo:
      // record chunk hash of visual
      // send id of chunk to delete, instead of separate visuals

      // i mention of it here:
      // https://github.com/otse/GTA2.0/issues/24#issue-99421473
      return 1;
    }

    hit(from, using, damage) {
      var dmg, r;
      if (this.dead || this.kill) {
        return false;
      }
      dmg = 0;
      if (from.type === 'Zombie') {
        this.health -= 20;
        this.state('h', 1); // hit
        this.ses.out.h = true;
      }
      if ((using != null ? using.type : void 0) === 'Gun') {
        damage /= 2;
        this.health -= damage;
        this.state('h', 1); // hit
      } else if ((using != null ? using.type : void 0) === 'Melee') {
        damage /= 2;
        this.health -= damage;
        this.state('h', 1); // hit
      }
      r = Math.floor(Math.random() * 8);
      new Decal({
        decal: `b${r}`,
        x: this.props.x,
        y: this.props.y
      });
      this.checkup(from);
      this.ses.bubbles.push(`Hit for ${damage.toFixed(2)} down to ${this.health.toFixed(2)} HP`);
      //@ses.out.HP = @health
      //@ses.out.DMG = damage
      return 1;
    }

    checkup(from) {
      if (this.health <= 0) {
        this.kill = true;
        if (from.type === 'Player' && !from.bandit) {
          if (!this.bandit) {
            from.bandit = true;
            from.state('outlaw', 1);
            from.ses.out.OUTLAW = 1;
            from.ses.bubbles.push('You are now a bandit...');
          } else {
            from.ses.bubbles.push('You killed a bandit player.');
          }
        }
      }
      return 1;
    }

    die() {
      if (this.dead) {
        return;
      }
      this.kill = false;
      this.dead = true;
      this.state('d', Math.floor(Math.random() * 10));
      if (this.body != null) {
        gta.world.DestroyBody(this.body);
      }
      this.body = null;
      this.ses.out.DEAD = true;
      this.ses.bubbles.push("You are ded. Reload page to respawn (temporary)");
      this.dropall();
      return 1;
    }

    dropall() {
      var a, i, len, m, n, props, ref;
      ref = this.items;
      for (n in ref) {
        a = ref[n];
        for (m = 0, len = a.length; m < len; m++) {
          i = a[m];
          if (i.props.model === 'Hands') {
            continue;
          }
          props = {
            type: 'Pickup',
            model: i.props.model,
            x: this.props.x,
            y: this.props.y,
            z: 64
          };
          if (this.props.interior) {
            props.interior = this.props.interior;
          }
          new Pickup(props);
        }
      }
      return 1;
    }

  };

  CarDoor = class CarDoor {
    constructor(car1, index, door1) {
      this.car = car1;
      this.index = index;
      this.door = door1;
      this.props = {
        type: 'Car door',
        x: 0,
        xx: 0,
        y: 0,
        yy: 0,
        z: 0
      };
      this.type = 'Car door';
      this.seat = null;
      this.pose();
    }

    pose(v) {
      var center, newX, newY, r, x, xx, y, yy;
      center = {
        x: this.car.stats.width / 2,
        y: this.car.stats.height / 2
      };
      center = {
        x: this.car.props.x,
        y: this.car.props.y
      };
      r = this.car.props.r;
      x = this.car.props.x + this.door.x;
      y = this.car.props.y - this.door.y;
      newX = center.x + (x - center.x) * Math.cos(r) - (y - center.y) * Math.sin(r);
      newY = center.y + (x - center.x) * Math.sin(r) + (y - center.y) * Math.cos(r);
      x = this.car.props.x + this.door.x / 4;
      xx = center.x + (x - center.x) * Math.cos(r) - (y - center.y) * Math.sin(r);
      yy = center.y + (x - center.x) * Math.sin(r) + (y - center.y) * Math.cos(r);
      this.props.x = newX;
      this.props.y = newY;
      this.props.xx = xx;
      this.props.yy = yy;
      return 1;
    }

  };

  Car = (function() {
    class Car extends Visual {
      constructor(props) {
        var d, i, ref, ref1;
        super(props);
        // console.log 'car ctor'
        this.type = 'Car';
        if (this.props.id == null) {
          props.id = --Car.prototype.decrement;
        }
        this.id = `c${props.id}`;
        if (Car.prototype.carpool.hasOwnProperty(props.id)) {
          console.log(`CARPOOL: Can't spawn a ${props.color} ${props.model} with id #${props.id}; in carpool.`);
          return;
        }
        Car.prototype.carpool[`${props.id}`] = props.id;
        this.stats = gta.cars[props.model];
        this.doors = [];
        if (this.stats.doors != null) {
          ref = this.stats.doors;
          for (i in ref) {
            d = ref[i];
            this.doors.push(new CarDoor(this, i, d));
          }
        }
        this.state('m', props.model);
        this.state('c', props.color || ((ref1 = this.stats.colors) != null ? ref1[0] : void 0));
        // @state 'l', 0
        this.props.z = 64;
        this.health = 1000;
        this.acknowledged = false; // awful fix to interpolation
        this.driver = null;
        this.speed = 0;
        this.reduce();
        this.rechunk();
        // for late chunk admission
        this.update();
        // @at.sleeping = false
        this.embody();
      }

      // override
      dtor() {
        var has, ref;
        has = Car.prototype.carpool.hasOwnProperty(this.props.id);
        if (has) {
          delete Car.prototype.carpool[this.props.id];
        }
        if ((ref = this.mission) != null) {
          ref.callback(this, 'dtor');
        }
        if (this.body != null) {
          gta.world.DestroyBody(this.body);
        }
        this.body = null;
        super.dtor();
        return true;
      }

      embody() {
        var fd;
        this.bd = new box2d.Dynamics.b2BodyDef();
        this.bd.type = box2d.Dynamics.b2Body.b2_staticBody;
        this.bd.position.Set(this.props.x / gta.scaling, this.props.y / gta.scaling);
        this.polygonShape = new box2d.Collision.Shapes.b2PolygonShape;
        this.polygonShape.SetAsBox((this.stats.sizew / 2) / gta.scaling, (this.stats.sizeh / 2) / gta.scaling);
        fd = new box2d.Dynamics.b2FixtureDef;
        fd.shape = this.polygonShape;
        fd.filter.categoryBits = gta.masks.solid;
        fd.filter.maskBits = -1;
        this.body = gta.world.CreateBody(this.bd);
        this.body.SetAngle(this.props.r);
        this.body.SetUserData(this);
        this.fixture = this.body.CreateFixture(fd);
        return true;
      }

      beginContact(v) {
        // console.log "#{@id} touched #{v.id}"
        return 0;
      }

      postSolve(v, n) {
        //console.log "Car #{@props.model} hit #{v.type} for #{n}"
        if (v.type === 'Mob') { // or v.type is 'Zombie'
          if (this.speed > .15) {
            v.hit(this, null, 100);
          } else if (this.speed > .1) {
            v.hit(this);
          }
        }
        return 0;
      }

      // override
      whole() {
        return super.whole();
      }

      // override
      //pack: ->
      //a = super()

      //return a

      // override
      step() {
        var flag, ref;
        super.step();
        if (this.dtord === true) {
          return;
        }
        if ((this.driver != null) && (((ref = this.driver) != null ? ref.ses.in.b : void 0) != null)) {
          flag = zeroorone(this.driver.ses.in.b);
          if (flag !== this.states.b) {
            this.state('b', flag);
          }
        }
        this.body.SetPosition(new box2d.Common.Math.b2Vec2(this.props.x / gta.scaling, this.props.y / gta.scaling));
        this.body.SetAngle(this.props.r);
        return true;
      }

      hit(from, using, damage) {
        if (using.type === 'Gun') {
          this.state('h', Math.floor(Math.random() * 9));
        }
        return true;
      }

      // override
      after() {
        delete this.states.h;
        // delete @states.d
        // delete @states.b
        return true;
      }

      // override
      pose(o) {
        var d, delta, len, m, ref, travel, x, y;
        if (!this.acknowledged) {
          return;
        }
        if (this.driver != null) {
          x = o[0] || this.props.x;
          y = o[1] || this.props.y;
          travel = Math.hypot(this.props.x - x, this.props.y - y);
          delta = Math.min(this.driver.ses.delta, 100);
          x = parseFloat(x.toFixed(1));
          y = parseFloat(y.toFixed(1));
          this.speed = travel / delta;
        } else {
          
          // console.log "#{travel.toFixed 2} of #{@props.x.toFixed 1},#{@props.y.toFixed 1} to #{x},#{y} : #{@speed}"
          this.speed = 0;
        }
        if (o[0] != null) {
          this.props.x = o[0];
        }
        if (o[1] != null) {
          this.props.y = o[1];
        }
        if (o[2] != null) {
          this.props.r = o[2];
        }
        ref = this.doors;
        for (m = 0, len = ref.length; m < len; m++) {
          d = ref[m];
          d.pose();
        }
        this.reduce();
        this.update();
        return 0;
      }

      enter(ply) {
        if (!ply.passenger) {
          this.acknowledged = false;
          this.driver = ply;
        }
        ply.car = this;
        this.speed = 0;
        return 0;
      }

      exit(ply) {
        var people;
        if (!ply.passenger) {
          this.driver = null;
          this.state('b', 0); // 'braking'
        }
        ply.cardoor.seat = null;
        ply.cardoor = null;
        people = (this.doors.slice(0).filter(function(e) {
          return e.seat != null;
        })).length;
        if (!people) {
          this.state('l', 0);
        }
        this.speed = 0;
        return 0;
      }

    };

    Car.prototype.increment = 0;

    Car.prototype.decrement = 0;

    Car.prototype.carpool = {};

    return Car;

  }).call(this);

  Pickup = (function() {
    class Pickup extends Visual {
      constructor(props) {
        super(props);
        this.type = 'Pickup';
        // rework this
        /*if not props.rarity?
        			for k, v of gta.drops
        				if v.indexOf(props.type) isnt -1
        @props.rarity = k
        break*/
        props.x += Math.random();
        props.y += Math.random();
        if (props.id == null) {
          props.id = Pickup.prototype.decrement--;
        }
        this.id = `u${props.id}`;
        this.state('model', props.model);
        this.embody();
        this.reduce();
        if (!this.props.static) {
          this.rechunk();
          
          // for late chunk admission
          this.update();
        }
        this.props.static = false;
      }

      // @at.sleeping = false

      // override
      dtor() {
        gta.world.DestroyBody(this.body);
        this.body = null;
        super.dtor();
        return true;
      }

      embody() {
        var fd;
        this.bd = new box2d.Dynamics.b2BodyDef();
        this.bd.type = box2d.Dynamics.b2Body.b2_dynamicBody;
        this.bd.position.Set(this.props.x / gta.scaling, this.props.y / gta.scaling);
        this.circleShape = new box2d.Collision.Shapes.b2CircleShape(4 / gta.scaling);
        fd = new box2d.Dynamics.b2FixtureDef;
        fd.shape = this.circleShape;
        fd.density = 1;
        if (!this.props.interior) {
          fd.filter.categoryBits = gta.masks.items;
          fd.filter.maskBits = gta.masks.solid | gta.masks.items;
        } else {
          fd.filter.categoryBits = gta.masks.intritems;
          fd.filter.maskBits = gta.masks.intrsolid | gta.masks.intritems;
        }
        this.body = gta.world.CreateBody(this.bd);
        this.body.SetUserData(this);
        this.fixture = this.body.CreateFixture(fd);
        this.body.SetLinearDamping(0.5);
        this.body.SetAngularDamping(0.5);
        return true;
      }

      
      // override
      whole() {
        return super.whole();
      }

      // override
      //pack: ->
      //a = super()

      //return a

      // override
      pose() {
        var con, pos;
        pos = this.body.GetPosition();
        this.props.x = pos.x * gta.scaling;
        this.props.y = pos.y * gta.scaling;
        this.props.r = this.body.GetAngle();
        this.reduce();
        con = this.before.reduced.x !== this.reduced.x || this.before.reduced.y !== this.reduced.y || this.before.reduced.z !== this.reduced.z;
        if (con) {
          this.update();
        }
        return true;
      }

      // override
      step() {
        if (this.dtord) {
          console.log("we are dtord");
        }
        if (this.dtord) {
          return;
        }
        this.pose();
        return true;
      }

    };

    Pickup.prototype.increment = 0;

    Pickup.prototype.decrement = 0;

    return Pickup;

  }).call(this);

  Item = class Item {
    constructor(props1) {
      this.props = props1;
      this.type = 'Item';
      this.owner = null;
    }

    select() {
      return true;
    }

    step() {
      return true;
    }

    use() {
      return true;
    }

  };

  Hands = class Hands extends Item {
    constructor(props) {
      super(props);
      this.type = 'Hands';
    }

    select() {
      return true;
    }

    step() {
      return true;
    }

    use() {
      return true;
    }

  };

  BlueGloves = class BlueGloves extends Item {
    constructor(props) {
      super(props);
      this.type = 'Blue gloves';
      this.equipped = false;
    }

    select() {
      var states;
      states = this.owner.states;
      if (this.skin == null) {
        this.skin = states.o.substr(0, 2);
      }
      console.log(this.skin);
      this.equipped = !this.equipped;
      if (this.equipped) {
        states.o = `su${states.o.substr(2)}`;
        this.owner.ses.bubbles.push('You look like you\'re going to rob a bank!');
      } else {
        states.o = `${this.skin}${states.o.substr(2)}`;
      }
      this.owner.refresh();
      return 1;
    }

    step() {
      return 1;
    }

    use() {
      return 1;
    }

  };

  Gun = class Gun extends Item {
    constructor(props, model) {
      super(props);
      this.model = model;
      this.type = 'Gun';
      this.fired = gta.frame + this.model.firerate;
    }

    // override
    select() {
      this.fired = gta.frame + this.model.firerate;
      return true;
    }

    // override
    use() {
      var base, catchers, cb, damage, decal, dropoff, len, m, o, origin, p1, p2, probe, r, reach, recoil, spread;
      super.use();
      if (!(gta.frame >= this.fired)) {
        return;
      }
      // todo: cleanup this function it's a tad crowded
      this.fired = gta.frame + this.model.firerate;
      this.owner.recoil += 0.15;
      if (this.owner.recoil > 1) {
        this.owner.recoil = 1;
      }
      recoil = 1 + this.owner.recoil * this.model.recoil * 3;
      base = .1; // minimum spread
      spread = (1 - this.model.accuracy) * Math.random() * base * recoil;
      r = this.owner.props.r;
      if (Math.random() < .5) {
        r -= spread;
      } else {
        r += spread;
      }
      reach = this.model.range * (448 * 2);
      origin = {
        x: this.owner.props.x,
        y: this.owner.props.y
      };
      probe = {
        x: origin.x + reach * Math.cos(r - (Math.PI / 2)),
        y: origin.y + reach * Math.sin(r - (Math.PI / 2))
      };
      this.owner.ses.out.LINE = {
        x: probe.x,
        y: probe.y
      };
      decal = (function() {
        switch (this.model.type) {
          case 'Shotgun':
            return 'c1';
          case 'Handgun':
            return 'c2';
          case 'SMG':
            return 'c3';
          case 'Carbine':
            return 'c3';
          case 'AR':
            return 'c4';
          case 'Sniper':
            return 'c5';
          case 'DMR':
            return 'c5';
          default:
            return null;
        }
      }).call(this);
      if (decal != null) {
        new Casing({
          decal: decal,
          x: origin.x,
          y: origin.y,
          eject: this.owner.props.r - Math.PI / 2 - 0.8,
          interior: this.owner.props.interior || null
        });
      }
      // lexical vars for cb-closure
      catchers = [];
      cb = function(x) {
        var range, v, y;
        v = x.m_body.GetUserData();
        if (v == null) {
          return; // ??...
        }
        x = Math.abs(v.props.x - origin.x);
        y = Math.abs(v.props.y - origin.y);
        range = Math.hypot(x, y);
        switch (v.type) {
          case 'Block':
          case 'Mob':
          case 'Zombie':
          case 'Player':
          case 'Car':
            break;
          default:
            return;
        }
        catchers.push({
          v: v,
          range: range
        });
        return true;
      };
      p1 = this.owner.body.GetPosition();
      p2 = new box2d.Common.Math.b2Vec2(probe.x / gta.scaling, probe.y / gta.scaling);
      gta.world.RayCast(cb, p1, p2);
      catchers.sort(function(a, b) {
        if (a.range < b.range) {
          return -1;
        } else {
          return 1;
        }
      });
      for (m = 0, len = catchers.length; m < len; m++) {
        o = catchers[m];
        if (o.v.props.interior !== this.owner.props.interior) {
          continue;
        }
        if (o.type === 'Block') {
          break;
        }
        if (o.range <= reach * .25) { // maximum damage
          damage = this.model.damage;
        } else {
          dropoff = this.model.damage * (o.range - reach) / -reach;
          damage = Math.max(dropoff, this.model.damage * .6);
        }
        o.v.hit(this.owner, this, damage);
        break;
      }
      this.owner.state('g', 1);
      this.owner.ses.out.g = 1;
      return true;
    }

  };

  Melee = class Melee extends Item {
    constructor(props, model) {
      super(props);
      this.model = model;
      this.type = 'Melee';
      this.swung = gta.frame;
      this.impact = true;
    }

    // override
    select() {
      this.swung = gta.frame;
      return 1;
    }

    // override
    step() {
      if (gta.frame >= this.swung - 3 && !this.impact) {
        this.attack();
      }
      return 1;
    }

    attack() {
      var v;
      this.impact = true;
      v = this.owner.find(['Player', 'Mob', 'Zombie', 'Car'], this.owner.ses.visuals, 8, 16);
      if (v != null) {
        v.hit(this.owner, this, this.model.damage);
      }
      return 1;
    }

    // override
    use() {
      super.use();
      if (!(gta.frame >= this.swung)) {
        return;
      }
      this.swung = gta.frame + this.model.firerate;
      this.impact = false;
      this.owner.state('s', 1);
      // @owner.ses.out.s = 1
      return 1;
    }

  };

  Decal = class Decal extends Visual {
    constructor(props) {
      super(props);
      this.type = 'Decal';
      this.id = `d${gta.decalpool++}`;
      this.state('decal', props.decal);
      this.spawn = Date.now();
      this.reduce();
      this.rechunk();
    }

    // override
    dtor() {
      super.dtor();
      // gta.world.DestroyBody @body
      return true;
    }

    // override
    step() {
      if (this.spawn < Date.now() - 3000) {
        this.dtor();
        return;
      }
      this.pose();
      return true;
    }

    // override
    whole() {
      return super.whole();
    }

    // override
    //pack: ->
    //a = super()

    //return a

    // override
    pose() {
      var con;
      this.reduce();
      con = this.before.reduced.x !== this.reduced.x || this.before.reduced.y !== this.reduced.y || this.before.reduced.r !== this.reduced.r || this.before.reduced.z !== this.reduced.z;
      if (con) {
        this.update();
      }
      return true;
    }

  };

  Casing = class Casing extends Decal {
    constructor(props) {
      var ejectat, spin;
      super(props);
      props.z = 64;
      props.r = Math.random() * Math.PI;
      ejectat = {
        x: props.x + 8 * Math.cos(props.eject + (Math.random() * .1)),
        y: props.y + 8 * Math.sin(props.eject + (Math.random() * .1))
      };
      props.x = ejectat.x;
      props.y = ejectat.y;
      // x = ejectat.x + .00001 * Math.cos props.eject #- (Math.PI/2)
      // y = ejectat.y + .00001 * Math.sin props.eject #- (Math.PI/2)
      spin = Math.random() * 60;
      if (Math.random() < .5) {
        spin = -spin;
      }
      this.state('spin', spin);
      this.reduce();
      this.rechunk();
    }

  };

  Block = class Block { // pseudo vis
    constructor(props1) {
      this.props = props1;
      this.type = 'Block';
      this.props.x += .5;
      this.props.y += .5;
      this.props.x *= 64;
      this.props.y *= 64;
      if (this.props.z === 1 && this.props.type === 'Block') { // or
        // @props.z is -1 and @props.type is 'Surface'
        this.embody();
      }
    }

    hit() {
      return 0;
    }

    step() {}

    pack() {
      return null;
    }

    collect() {
      return false;
    }

    whole() {
      return null;
    }

    after() {}

    dtor() {
      if (this.body != null) {
        gta.world.DestroyBody(this.body);
      }
      return true;
    }

    embody() {
      var fd;
      this.bd = new box2d.Dynamics.b2BodyDef();
      this.bd.type = box2d.Dynamics.b2Body.b2_staticBody;
      this.bd.position.Set(this.props.x / gta.scaling, this.props.y / gta.scaling);
      this.polygonShape = new box2d.Collision.Shapes.b2PolygonShape;
      this.polygonShape.SetAsBox(32 / gta.scaling, 32 / gta.scaling);
      fd = new box2d.Dynamics.b2FixtureDef;
      fd.shape = this.polygonShape;
      fd.filter.categoryBits = gta.masks.solid;
      fd.filter.maskBits = -1;
      this.body = gta.world.CreateBody(this.bd);
      this.body.SetUserData(this);
      this.fixture = this.body.CreateFixture(fd);
      return true;
    }

    beginContact() {
      return 0;
    }

    postSolve() {
      return 0;
    }

  };

  Door = class Door { // pseudo visual
    constructor(props1) {
      var rotations;
      this.props = props1;
      this.type = 'Door';
      this.vjson = this.props.vjson == null ? {} : JSON.parse(this.props.vjson);
      if (this.vjson.to == null) {
        this.type = 'Poorly scripted door'; // this works tho ._.
      }
      if (this.props.r == null) {
        this.props.r = 0;
      }
      rotations = [[0, 31.95], [31.95, 0], [0, -31.95], [-31.95, 0]];
      this.props.x += .5;
      this.props.y += .5;
      this.props.x *= 64;
      this.props.y *= 64;
      this.props.x += rotations[this.props.r][0];
      this.props.y += rotations[this.props.r][1];
    }

    displace(ply, out) {
      var inside, outside, rotations, x, y;
      inside = [[0, 16], [16, 0], [0, -16], [-16, 0]];
      outside = [[0, -16], [-16, 0], [0, 16], [16, 0]];
      rotations = out ? outside : inside;
      x = this.props.x;
      y = this.props.y;
      x += rotations[this.props.r][0];
      y += rotations[this.props.r][1];
      ply.props.x = x;
      ply.props.y = y;
      ply.reduce();
      return true;
    }

    dtor() {}

    step() {}

    pack() {
      return null;
    }

    collect() {
      return null;
    }

    whole() {
      return null;
    }

    after() {}

  };

  Interior = class Interior {
    constructor(name1) {
      this.name = name1;
      console.log(`making new interior: ${this.name}`);
      this.occupants = [];
      gta.intrs[this.name] = this;
    }

    // WHERE x >= #{@ux} AND y >= #{@uy} AND x < #{@uex} AND y < #{@uey}
    /*
    query = "SELECT * FROM `visuals` WHERE interior = \"#{@name}\""
    gta.db.query query, (err, rows) ->
    	gta.factory r for r in rows
    	return

    query = "SELECT * FROM `cars` WHERE interior = \"#{@name}\""
    gta.db.query query, (err, rows) ->
    	new Car r for r in rows
    	return
    */
    dtor() {
      console.log("dtor of interior");
      return 0;
    }

    leave(ply1) {
      var i;
      this.ply = ply1;
      i = this.occupants.indexOf(this.ply);
      this.occupants.splice(i, 1);
      return true;
    }

    step() {
      if (!this.occupants.length) {
        this.dtor();
        return false;
      }
      return true;
    }

  };

  Activator = (function() {
    class Activator extends Visual {
      constructor(props) {
        // console.log "Activator ##{props.id} of type #{props.type}"
        super(props);
        this.type = 'Activator';
        if (props.id == null) {
          props.id = --Activator.prototype.idpool;
        }
        this.id = `m${props.id}`;
        this.model = gta.activators[this.props.type];
        this.embody();
        this.state('type', props.type);
        // @spawn = Date.now()
        this.reduce();
        if (!this.props.static) {
          this.rechunk();
          // for late chunk admission
          this.update();
        } else {

        }
      }

      // console.log "#{props.type} is static"
      // @at.sleeping = false
      dtor() {
        if (this.body != null) {
          gta.world.DestroyBody(this.body);
        }
        this.body = null;
        super.dtor();
        return true;
      }

      embody() {
        var fd;
        this.bd = new box2d.Dynamics.b2BodyDef();
        this.bd.type = box2d.Dynamics.b2Body.b2_staticBody;
        this.bd.position.Set(this.props.x / gta.scaling, this.props.y / gta.scaling);
        this.polygonShape = new box2d.Collision.Shapes.b2PolygonShape;
        this.polygonShape.SetAsBox((this.model.sprite.width / 2) / gta.scaling, (this.model.sprite.height / 2) / gta.scaling);
        fd = new box2d.Dynamics.b2FixtureDef;
        fd.shape = this.polygonShape;
        fd.filter.categoryBits = gta.masks.solid;
        fd.filter.maskBits = -1;
        this.body = gta.world.CreateBody(this.bd);
        this.body.SetAngle(this.props.r);
        this.body.SetUserData(this);
        this.fixture = this.body.CreateFixture(fd);
        return true;
      }

      // override
      step() {
        // @pose()
        return true;
      }

      // override
      whole() {
        return super.whole();
      }

      // override
      //pack: ->
      //a = super()

      //return a

      // override
      pose() {
        // @reduce()

        // @update() if con
        return true;
      }

      use() {
        return this.props.type;
      }

    };

    Activator.prototype.idpool = 0;

    return Activator;

  }).call(this);

  ATM = class ATM extends Activator {
    constructor(props) {
      super(props);
    }

    // override
    use() {
      return "*Crrrtrr* (ATM Machine)";
    }

  };

  VendingMachine = class VendingMachine extends Activator {
    constructor(props) {
      super(props);
    }

    // override
    use() {
      return "*Sszzr* (Vending Machine)";
    }

  };

  LabFreezer = class LabFreezer extends Activator {
    constructor(props) {
      super(props);
    }

    // override
    use() {
      return "Lab Freezer";
    }

  };

  VacuumOven = class VacuumOven extends Activator {
    constructor(props) {
      super(props);
    }

    // override
    use() {
      return "Vacuum Oven";
    }

  };

  Incubator = class Incubator extends Activator {
    constructor(props) {
      super(props);
      this.bleepbep = true;
    }

    // override
    use() {
      return "Incubator";
    }

  };

  Generator = class Generator extends Activator {
    constructor(props) {
      super(props);
      this.on = false;
      this.reserve = 0;
      this.cable = new Cable;
    }

    // override
    use() {
      return "*Vbrrrr* (Generator)";
    }

  };

  Worklight = class Worklight extends Activator {
    constructor(props) {
      super(props);
      this.on = true;
      this.state('o', 1);
    }

    // override
    use() {
      this.on = this.on ? 0 : 1;
      this.state('o', this.on);
      return "*Vrzzzzmzmz* (Worklight)";
    }

  };

  Terminal = class Terminal extends Activator {
    constructor(props) {
      super(props);
      this.on = true;
    }

    // @state 'o', 1

    // override
    use() {
      // @on = if @on then 0 else 1

      // @state 'o', @on
      return "Terminal";
    }

  };

  Teleporter = class Teleporter extends Activator {
    constructor(props) {
      super(props);
      this.on = true;
    }

    // @state 'o', 1

    // override
    use() {
      // @on = if @on then 0 else 1

      // @state 'o', @on
      return "Teleporter";
    }

  };

  Cable = class Cable { // extends Visual
    constructor(props) {}

    // super props
    embody() {
      return true;
    }

    nice() {
      return true;
    }

  };

  Dumpster = class Dumpster extends Activator {
    constructor(props) {
      super(props);
      this.varrr = false;
    }

    // @state 'o', 1

    // override
    use() {
      // @on = if @on then 0 else 1

      // @state 'o', @on
      return "Dumpster";
    }

  };

  Chunk = class Chunk {
    constructor(x1, y1) {
      var len, len1, m, r, ref, ref1, s, v, w, z;
      this.x = x1;
      this.y = y1;
      // console.log "chunk ctor #{@x},#{@y}"
      this.sleeping = true;
      this.stamp = gta.frame;
      this.expire = this.stamp + gta.chunklife;
      this.observed = false;
      this.peekaboo = 0;
      this.firststep = true; // used for mob spawning
      this.intrs = {}; // should be {}
      this.subscribers = [];
      this.hash = `${this.x},${this.y}`;
      this.walks = gta.walksbych[this.hash] || null;
      this.parkingspaces = gta.parkingspacesbych[this.hash] || null;
      this.entities = gta.entitiesbych[this.hash] || null;
      if (this.entities != null) {
        // console.log "hash #{@hash} entitiesbych".red
        console.log(`chunk ${this.hash} has ${this.entities.length} ents`.red);
      }
      this.visuals = [];
      // @solids = []
      this.peds = 0;
      this.pedsbound = 0;
      if (this.walks != null) {
        ref = this.walks;
        for (m = 0, len = ref.length; m < len; m++) {
          w = ref[m];
          this.pedsbound += w.pedsbound;
          w.pedsbound = 0;
        }
      }
      // console.log "#{@pedsbound} pedestrians were already bound for chunk #{@hash}"
      gta.chunks[this.hash] = this;
      this.removes = [];
      this.build = [];
      this.all = [];
      this.allstamp = -1;
      this.ux = this.x * gta.chunkunits;
      this.uy = this.y * gta.chunkunits;
      this.uex = this.ux + gta.chunkunits;
      this.uey = this.uy + gta.chunkunits;
      this.fetch();
      if (gta.raws[this.hash] != null) {
        ref1 = gta.raws[this.hash];
        for (z = 0, len1 = ref1.length; z < len1; z++) {
          r = ref1[z];
          s = JSON.parse(JSON.stringify(r)); // todo: maybe shallow-copy the array instead
          s.static = true;
          v = gta.factory(s);
          this.put(v);
          v.at = this;
        }
      }
    }

    dtor() {
      var len, m, ref, v;
      ref = this.visuals.slice(0);
      for (m = 0, len = ref.length; m < len; m++) {
        v = ref[m];
        v.dtor();
      }
      // s.dtor() for s in @solids
      return true;
    }

    subscribe(ply) {
      var i;
      i = this.subscribers.indexOf(ply);
      if (i === -1) {
        this.subscribers.push(ply);
      }
      return true;
    }

    unsubscribe(ply) {
      var i;
      i = this.subscribers.indexOf(ply);
      if (i !== -1) {
        this.subscribers.splice(i, 1);
      }
      return true;
    }

    step() {
      var c, e, i, i1, j1, k1, l1, len, len1, len2, len3, len4, limit, link, m, narrowed, o, options, p, peekaboo, ref, ref1, ref2, ref3, ref4, ref5, routines, set, v, z;
      if (gta.frame >= this.expire) {
        this.dtor();
        return false;
      }
      peekaboo = 0;
      ref = this.intrs;
      // if @firststep
      // for [0..5]
      // new Zombie x: @x*gta.chunkunits, y: @y*gta.chunkunits, z:64
      for (i in ref) {
        o = ref[i];
        if ((gta.intrs[i] != null) && o.peekaboo === 0) {
          o.peekaboo = 1;
          if (this.entities != null) {
            ref1 = this.entities;
            for (m = 0, len = ref1.length; m < len; m++) {
              e = ref1[m];
              if (e.props.interior && (gta.intrs[e.props.interior] != null)) {
                e.event('peekaboo');
              }
            }
          }
        } else if (gta.intrs[i] != null) {
          o.peekaboo = 2;
        } else if (gta.intrs[i] == null) {
          o.peekaboo = 0;
        }
      }
      if (this.observed && this.peekaboo === 0) {
        this.peekaboo = 1;
      } else if (this.observed) {
        this.peekaboo = 2;
      } else if (!this.observed) {
        this.peekaboo = 0;
      }
      // @peds = (@visuals.slice(0).filter (e) -> e.type is 'Mob').length

      // @congestion = @peds > 15
      limit = 2;
      if (this.observed && (this.walks != null) && limit - this.pedsbound > 0) {
        for (z = 1, ref2 = limit - this.pedsbound; (1 <= ref2 ? z <= ref2 : z >= ref2); 1 <= ref2 ? z++ : z--) {
          options = Walk.prototype.crossoversbych[this.hash];
          narrowed = [];
          for (i1 = 0, len1 = options.length; i1 < len1; i1++) {
            set = options[i1];
            c = gta.chunks[set.from.hash];
            if ((c != null) && c.observed) {
              continue;
            }
            narrowed.push(set);
          }
          if (!narrowed.length) {
            break;
          }
          link = random(narrowed);
          routines = ['Pedestrian'];
          if (Math.random() < .33) {
            routines.push('TakeABreak');
          }
          // subtype = 'Hitman' if Math.random() < .2
          new Mob({
            type: 'Mob',
            // subtype: subtype
            routines: routines,
            ch: this.hash,
            from: link.from.vjson.id,
            to: link.to.vjson.id
          });
        }
      }
      if (this.peekaboo === 1) {
        // console.log "peekaboo is 1 for #{@x}, #{@y}"
        if (this.parkingspaces != null) {
          ref3 = this.parkingspaces;
          for (j1 = 0, len2 = ref3.length; j1 < len2; j1++) {
            p = ref3[j1];
            p.event('peekaboo');
          }
        }
        if (this.entities != null) {
          ref4 = this.entities;
          for (k1 = 0, len3 = ref4.length; k1 < len3; k1++) {
            e = ref4[k1];
            e.event('peekaboo');
          }
        }
      }
      ref5 = this.visuals.slice(0);
      for (l1 = 0, len4 = ref5.length; l1 < len4; l1++) {
        v = ref5[l1];
        if (v == null) {
          continue;
        }
        if (v.props.interior && (gta.intrs[v.props.interior] == null)) {
          continue;
        }
        v.step();
      }
      return true;
    }

    beyond(chunk) {
      var o;
      o = {
        x: Math.abs(this.x - chunk.x),
        y: Math.abs(this.y - chunk.y)
      };
      return o.x > 1 || o.y > 1;
    }

    fetch() {
      var chunk;
      chunk = this;
      /*
      query = "SELECT * FROM `cars` WHERE x >= #{@ux} AND y >= #{@uy} AND x < #{@uex} AND y < #{@uey} AND interior is NULL"
      gta.db.query query, (err, rows) ->
      	new Car r for r in rows
      	return

       * query = "SELECT * FROM `pickups` WHERE x >= #{@ux} AND y >= #{@uy} AND x < #{@uex} AND y < #{@uey}"
       * gta.db.query query, (err, rows) ->
       * 	new Pickup r for r in rows
       * 	return

      query = "SELECT * FROM `visuals` WHERE x >= #{@ux} AND y >= #{@uy} AND x < #{@uex} AND y < #{@uey} and interior is NULL"
      gta.db.query query, (err, rows) ->
      	gta.factory r for r in rows
      	return
       */
      return true;
    }

    put(v) {
      this.visuals.push(v);
      this.reserveintr(v);
      return true;
    }

    putcheck(v) {
      var i;
      i = this.visuals.indexOf(v);
      if (i === -1) {
        this.visuals.push(v);
        this.reserveintr(v);
      }
      return true;
    }

    // use keep if vis isnt also being dtored
    withdraw(v, keep) {
      var has, i;
      i = this.visuals.indexOf(v);
      has = i > -1;
      if (has) {
        this.visuals.splice(i, 1);
      }
      if (!keep) {
        this.removes.push(v.id);
      }
      v.at = null; // unless keep
      v.served = false;
      return has;
    }

    after() {
      var len, m, ref, v;
      this.sleeping = true;
      if (this.observed) {
        this.stamp = gta.frame;
        this.expire = this.stamp + gta.chunklife;
      }
      this.removes = [];
      ref = this.visuals.slice(0);
      for (m = 0, len = ref.length; m < len; m++) {
        v = ref[m];
        v.after();
      }
      return true;
    }

    reserveintr(v) {
      var name;
      if (v.props.interior == null) {
        return;
      }
      // console.log "#{v.type} is in interior #{v.props.interior}".green
      name = v.props.interior;
      if (this.intrs[name] == null) {
        this.intrs[name] = {
          instance: null,
          all: [],
          build: [],
          peekaboo: 0
        };
      }
      // console.log "actual reserveintr by #{@hash} for `#{name}`; #{@intrs[name].all.length}".green
      return true;
    }

    compile() {
      var build, i, intr, len, m, o, ref, ref1, v;
      this.build = [];
      ref = this.intrs;
      for (i in ref) {
        o = ref[i];
        o.build = [];
      }
      if (this.sleeping) {
        return;
      }
      ref1 = this.visuals;
      // console.log "compiling #{@hash} at #{gta.frame}"
      for (m = 0, len = ref1.length; m < len; m++) {
        v = ref1[m];
        build = this.build;
        if (intr = v.props.interior) {
          if (gta.intrs[intr] == null) {
            continue;
          }
          build = this.intrs[intr].build;
        }
        if (!v.served) {
          v.served = true;
          build.push(v.whole());
        } else if (v.collect()) {
          build.push(v.pack());
        }
      }
      return 0;
    }

    whole(intr) {
      var all, i, k, len, m, o, ref, ref1, v;
      // if intr? and not @intrs[intr.name]?
      // console.log 'chunk does not house intr'
      // return []
      if (this.allstamp !== gta.frame) {
        // console.log "serving #{@hash} whole at #{gta.frame}"
        this.all = [];
        this.allstamp = gta.frame;
        ref = this.intrs;
        for (i in ref) {
          o = ref[i];
          o.all = [];
        }
        ref1 = this.visuals;
        for (m = 0, len = ref1.length; m < len; m++) {
          v = ref1[m];
          all = this.all;
          if (k = v.props.interior) {
            all = this.intrs[k].all;
          }
          v.served = true;
          all.push(v.whole());
        }
      }
      if (intr != null) {
        return this.intrs[intr].all;
      } else {
        return this.all;
      }
    }

    pack(stamp, intr, intrstamp) {
      var a;
      a = [];
      a = stamp === gta.frame ? this.whole() : this.build;
      if ((intr != null) && (this.intrs[intr] != null)) {
        a = a.concat(intrstamp === gta.frame ? this.whole(intr) : this.intrs[intr].build);
      }
      return a;
    }

  };

  Entity = (function() {
    class Entity extends Visual {
      constructor(props) {
        var x, y;
        super(props);
        this.type = 'Entity';
        this.props.static = false; // hm
        this.id = `e${this.props.id || this.vjson.id || -1}`;
        x = Math.floor(this.props.x / gta.chunkunits);
        y = Math.floor(this.props.y / gta.chunkunits);
        this.hash = `${x},${y}`;
        this.categorize();
        this.init();
      }

      pack() {
        return null;
      }

      collect() {
        return false;
      }

      whole() {
        return null;
      }

      step() {
        if (!super.step()) {
          return;
        }
        if (this.props.interior) {
          return console.log(`${this.vjson.type} step`.green);
        }
      }

      init() {
        switch (this.vjson.type) {
          case 'Vendor':
            this.reservedid = Mob.prototype.ids++;
        }
        return 1;
      }

      categorize() {
        var c;
        gta.entities[this.vjson.id] = this;
        c = gta.entitiesbych[this.hash] || (gta.entitiesbych[this.hash] = []);
        c.push(this);
        return 0;
      }

      event(e) {
        var vendor;
        if (this.props.interior && (gta.intrs[this.props.interior] == null)) {
          return;
        }
        console.log(`Entity event at ${this.hash}`.cyan);
        if (e === 'peekaboo') {
          switch (this.vjson.type) {
            case 'Vendor':
              console.log(`making vendor in intr ${this.props.interior}`.green);
              vendor = {
                id: this.reservedid,
                type: 'Mob',
                routines: ['Vendor'],
                x: this.props.x,
                y: this.props.y,
                z: 64,
                r: this.vjson.r,
                interior: this.props.interior
              };
              new Mob(vendor);
          }
        }
        return 0;
      }

    };

    Entity.prototype.idpool = 0;

    return Entity;

  }).call(this);

  Drive = class Drive extends Entity {
    constructor(props) {
      super(props);
      this.type = 'Drive';
    }

    categorize() {
      gta.drives[this.vjson.id] = this;
      // c = gta.walksbych[ @hash ] or gta.walksbych[ @hash ] = []
      // c.push this
      return 0;
    }

    step() {
      return 0;
    }

  };

  Walk = (function() {
    class Walk extends Entity {
      pairhash(a, b) {
        return `${Math.min(a.vjson.id, b.vjson.id)},${Math.max(a.vjson.id, b.vjson.id)}`;
      }

      gettweens(a, b) {
        return Walk.prototype.tweensbypairs[Walk.prototype.pairhash(a, b)];
      }

      constructor(props) {
        super(props);
        this.type = 'Walk';
        this.angletoid = [];
        this.tweensbylink = [];
        this.pedsbound = 0;
        if ((this.vjson.id == null) || (this.vjson.type == null) || (this.vjson.links == null)) {
          console.log('walk node is malformed'.yellow);
        }
      }

      categorize() {
        var c;
        gta.walks[this.vjson.id] = this;
        c = gta.walksbych[this.hash] || (gta.walksbych[this.hash] = []);
        c.push(this);
        return 0;
      }

      step() {
        return 0;
      }

      preprocess() {
        var array, base1, base2, d, i, i1, j, j1, l, len, len1, len2, links, m, name1, pair, range, theta, tween, tweens, x, y, z;
        links = this.vjson.links;
        if (links == null) {
          return;
        }
// bake intermediate positions between links; aka tweens
        for (m = 0, len = links.length; m < len; m++) {
          i = links[m];
          l = gta.walks[i];
          if (l == null) {
            continue;
          }
          // continue unless @vjson.type is w.vjson.type
          pair = Walk.prototype.pairhash(this, l);
          tweens = (base1 = Walk.prototype.tweensbypairs)[pair] != null ? base1[pair] : base1[pair] = [];
          theta = Math.atan2(this.props.y - l.props.y, this.props.x - l.props.x);
          x = Math.abs(this.props.x - l.props.x);
          y = Math.abs(this.props.y - l.props.y);
          for (j = z = 1; z <= 10; j = ++z) {
            range = j / 10 * Math.hypot(x, y);
            tween = {
              x: this.props.x - range * Math.cos(theta),
              y: this.props.y - range * Math.sin(theta)
            };
            tweens.push(tween);
          }
        }
// bake chunk refill / crossovers
        for (i1 = 0, len1 = links.length; i1 < len1; i1++) {
          i = links[i1];
          l = gta.walks[i];
          if (l == null) {
            continue;
          }
          if (l.hash === this.hash) {
            continue;
          }
          array = (base2 = Walk.prototype.crossoversbych)[name1 = this.hash] != null ? base2[name1] : base2[name1] = [];
          array.push({
            from: l,
            to: this
          });
        }
// then bake angles
        for (j1 = 0, len2 = links.length; j1 < len2; j1++) {
          i = links[j1];
          l = gta.walks[i];
          if (l == null) {
            continue;
          }
          theta = Math.atan2(this.props.y - l.props.y, this.props.x - l.props.x);
          theta *= 180 / Math.PI;
          d = parseFloat(theta.toFixed(1));
          this.angletoid[i] = d;
        }
        // console.log "angle from #{@vjson.id} to id #{i} is #{d}"
        return 1;
      }

    };

    Walk.prototype.tweensbypairs = {};

    Walk.prototype.crossoversbych = {};

    return Walk;

  }).call(this);

  SafeZone = class SafeZone extends Entity {
    constructor(props) {
      super(props);
      this.type = 'Safe Zone';
    }

    step() {
      return 0;
    }

  };

  ParkingSpace = class ParkingSpace extends Entity {
    constructor(props) {
      super(props);
      this.type = 'Parking space';
      this.reservedid = --Car.prototype.decrement;
      this.mission = null;
    }

    step() {
      return 0;
    }

    categorize() {
      var c;
      gta.parkingspaces[this.vjson.id] = this;
      c = gta.parkingspacesbych[this.hash] || (gta.parkingspacesbych[this.hash] = []);
      c.push(this);
      return 0;
    }

    event(e) {
      var car;
      if (this.mission != null) {
        this.mission.callback(this, e);
      } else if (this.vjson.model) {
        car = {
          id: this.reservedid,
          x: this.props.x,
          y: this.props.y,
          z: 64,
          r: this.vjson.r,
          owners: this.vjson.owners,
          model: this.vjson.model,
          color: this.vjson.color || false
        };
        car = new gta.Car(car);
        car.volatile = true; // unnecessary. todo: test w/o this flag
      }
      return 0;
    }

  };

  Routine = (function() {
    class Routine {
      priority() {
        return this.constructor.priority;
      }

      constructor(mob1, params1) {
        this.mob = mob1;
        this.params = params1;
        this.type = 'Untyped Routine';
      }

      step() {
        return 0;
      }

    };

    Routine.priority = 10;

    return Routine;

  }).call(this);

  Vendor = (function() {
    class Vendor extends Routine {
      constructor(mob, params) {
        super(mob, params);
        this.type = 'Vendor';
      }

      // ---
      step() {
        // vendors typically do nothing lool
        // if @mob.active isnt null
        // console.log 'can\'t be a ped if we are breaking'
        return 0;
      }

    };

    Vendor.priority = 5;

    return Vendor;

  }).call(this);

  Pedestrian = (function() {
    class Pedestrian extends Routine {
      constructor(mob, params) {
        super(mob, params);
        this.type = 'Pedestrian';
      }

      // ---
      step() {
        if (this.mob.active !== null) {
          console.log('can\'t be a ped if we are breaking');
        }
        return 0;
      }

    };

    Pedestrian.priority = 5;

    return Pedestrian;

  }).call(this);

  TakeABreak = (function() {
    class TakeABreak extends Routine {
      constructor(mob, params) {
        super(mob, params);
        this.type = 'TakeABreak';
        // ---
        this.breaking = false;
        this.framesperchance = this.params.framesperchance || 30 + Math.random() * 50;
        this.chance = this.params.chance / 100 || 50 / 100;
        this.framesforactivity = 10; // 10 = 1s because of game loop of 10hz/ 100ms
        this.lasttried = gta.frame;
      }

      step() {
        if (!((this.mob.active == null) || 'Pedestrian' === this.mob.active.type)) {
          return;
        }
        if (this.breaking && gta.frame - this.breaking >= this.framesforactivity) {
          // console.log 'ok broke enough'
          this.lasttried = gta.frame;
          this.breaking = false;
        } else if (gta.frame - this.lasttried >= this.framesperchance) {
          if (Math.random() < this.chance) {
            this.breaking = gta.frame;
            this.findBreakNode();
          }
        }
        return 0;
      }

      findBreakNode() {
        return 1;
      }

    };

    TakeABreak.priority = 1;

    return TakeABreak;

  }).call(this);

  Mob = (function() {
    class Mob extends Visual {
      static factory(mob, routine) {
        switch (routine) {
          case 'Vendor':
            return new Vendor(mob, routine);
          case 'Pedestrian':
            return new Pedestrian(mob, routine);
          case 'TakeABreak':
            return new TakeABreak(mob, routine);
          default:
            return null;
        }
      }

      constructor(props) {
        var body, feet, hair, legs, len, m, r, ref, skin;
        super(props);
        if (props.id == null) {
          props.id = Mob.prototype.ids++;
        }
        if (-1 !== Mob.prototype.pool.indexOf(this.props.id)) {
          console.log("Mob exists");
          return;
        }
        Mob.prototype.pool.push(this.props.id);
        this.type = 'Mob';
        this.id = `g${props.id}`;
        props.r = Math.random() * Math.PI;
        this.anchor = gta.chunks[props.ch];
        this.active = null;
        this.routines = [];
        ref = props.routines;
        for (m = 0, len = ref.length; m < len; m++) {
          r = ref[m];
          this.addroutine(r);
        }
        this.sortroutines();
        this.traversed = [];
        if (!this.spawn(this.anchor)) { // return refrains add to ch
          return;
        }
        this.embody();
        if (this.walk != null) {
          props.r = this.pointatv(this.walk);
        }
        this.reduce();
        this.rechunk();
        // : > BULLSHIT VARS FOLLOW : >

        // @state 'w', 1
        this.walking = false;
        this.running = false;
        // ccw,0 is left, 90 is bottom, -90 is top, 180 and -180 is right
        r = Math.ceil(Math.random() * 8);
        this.bearing = -180 + r * 45;
        this.aim = -1;
        this.turn = 0;
        this.bored = -1;
        this.pause = -1;
        this.stray = -1;
        this.floored = 0;
        skin = ['wh', 'wh', 'wh', 'gl', 'bl'][Math.floor(Math.random() * 5)];
        feet = ['lo', 'sn', 'al', 'dr'][Math.floor(Math.random() * 4)];
        legs = ['je', 'de', 'kh'][Math.floor(Math.random() * 3)];
        body = ['po', 'sw', 'bo', 'pa', 'sh', 'co'][Math.floor(Math.random() * 6)];
        hair = ['br'][Math.floor(Math.random() * 1)];
        if (skin === 'bl') { // black men have black hair
          hair = 'Bl';
        }
        if (legs === 'kh' && feet === 'lo') { // dress shoes when trying loafers /w khaki (bad contrast in brown shoes/pants)
          feet = 'dr';
        }
        if (skin === 'bl' && body === 'po') { // become white when black /w poncho
          skin = 'gl';
        }
        if (body === 'po') { // poncho hood
          hair = 'ph';
        }
        if (body === 'po' && legs === 'kh') { // jeans when trying khaki /w poncho (its too brown)
          legs = 'je';
        }
        if (body === 'po' && feet === 'dr') { // sneakers when trying dress shoes /w poncho (dress shoes too nice for ponchoman)
          feet = 'sn';
        }
        if (props.zombie) {
          skin = 'zo';
        }
        // @type = 'Zombie'
        if (props.subtype === 'Hitman') {
          skin = 'le';
          feet = 'dr';
          legs = 'de';
          body = 'sh';
          hair = 'ba';
          this.state('u', 'Compact 45');
        }
        this.state('o', `${skin}${feet}${legs}${body}${hair}`);
        this.parts = [];
        this.parts.push(skin, feet, legs, body, hair);
        this.briefcase = 1; // Math.random() < .5
        this.state('b', 1); // @briefcase
        this.health = 100;
        this.kill = false;
        this.dead = false;
        this.haste = 0.22 + Math.random() * 0.1;
        this.panic = false;
      }

      // override
      dtor() {
        var i, ref, ref1;
        i = Mob.prototype.pool.indexOf(this.props.id);
        if (i !== -1) {
          Mob.prototype.pool.splice(i, 1);
        }
        if ((ref = gta.chunks[(ref1 = this.walk) != null ? ref1.hash : void 0]) != null) {
          ref.pedsbound--;
        }
        if (this.body != null) {
          gta.world.DestroyBody(this.body);
        }
        this.body = null;
        super.dtor();
        return 1;
      }

      embody() {
        var fd;
        this.bd = new box2d.Dynamics.b2BodyDef();
        this.bd.type = box2d.Dynamics.b2Body.b2_dynamicBody;
        this.bd.position.Set(this.props.x / gta.scaling, this.props.y / gta.scaling);
        this.circleShape = new box2d.Collision.Shapes.b2CircleShape(6 / gta.scaling);
        fd = new box2d.Dynamics.b2FixtureDef;
        fd.shape = this.circleShape;
        fd.density = 1;
        if (!this.props.interior) {
          fd.filter.categoryBits = gta.masks.organic;
          fd.filter.maskBits = gta.masks.solid | gta.masks.organic;
        } else {
          fd.filter.categoryBits = gta.masks.introrganic;
          fd.filter.maskBits = gta.masks.intrsolid | gta.masks.introrganic;
        }
        // @fd.friction = 0.4
        this.body = gta.world.CreateBody(this.bd);
        this.body.SetAngle(this.props.r);
        this.body.SetUserData(this);
        this.fixture = this.body.CreateFixture(fd);
        this.body.SetLinearDamping(2.3);
        this.body.SetAngularDamping(1.5);
        return true;
      }

      // override
      whole() {
        return super.whole();
      }

      // override
      //pack: ->
      //a = super()

      //return a
      addroutine(r) {
        this.routines.push(Mob.factory(this, r));
        return 1;
      }

      sortroutines() {
        this.routines.sort(function(a, b) {
          if (a.priority() < b.priority()) {
            return -1;
          } else {
            return 1;
          }
        });
        return 1;
      }

      // override
      pose() {
        var at, con, pos, travel;
        pos = this.body.GetPosition();
        this.props.x = pos.x * gta.scaling;
        this.props.y = pos.y * gta.scaling;
        this.props.r = this.body.GetAngle();
        this.reduce();
        con = this.before.reduced.x !== this.reduced.x || this.before.reduced.y !== this.reduced.y || this.before.reduced.r !== this.reduced.r || this.before.reduced.z !== this.reduced.z;
        if (con) {
          at = this.at;
          travel = this.update();
          if (!this.at.observed && this.at.beyond(this.anchor)) {
            // console.log 'Mob may not travel unobserved for two chs, dtoring'
            this.dtor();
          }
        }
        return true;
      }

      // override
      step() {
        var floored, len, m, r, ref;
        if (this.dead) {
          this.rot();
        }
        if (this.dtord) {
          return;
        }
        if (this.body != null) {
          this.anim();
        }
        if (this.at.observed) {
          this.anchor = this.at;
        }
        if (this.kill) {
          this.die();
        }
        if (this.dead) {
          return;
        }
        floored = !(this.floored < Date.now() - 1500);
        if (floored) {
          return;
        }
        if (this.states.fall != null) {
          this.getup();
        }
        this.pose();
        if (this.dtord) {
          return;
        }
        ref = this.routines;
        for (m = 0, len = ref.length; m < len; m++) {
          r = ref[m];
          r.step();
        }
        this.move();
        //@agro()

        //@ramble()
        return true;
      }

      use() { // Mob::quotes[Math.floor Math.random() * Mob::quotes.length]
        return `My clothes are ${this.states.o}, and im a ${this.type}`;
      }

      // override
      after() {
        delete this.states.s;
        delete this.states.h;
        delete this.states.up;
        delete this.states.e;
        delete this.states.q;
        delete this.states.a; // alarmed
        delete this.states.r; // run over
        return true;
      }

      rot() {
        if (this.died < Date.now() - 60000) {
          this.dtor();
        }
        return true;
      }

      spawn(ch) {
        var c, i, l, len, link, links, m, options, ref, ref1, tween, tweens, walk, walks;
        if (indexOf.call(this.props.routines, 'Pedestrian') < 0) {
          return true;
        }
        // unless we a ped, we just spawn freely regardless of overpopulation
        if (ch.observed && ch.firststep) {
          // firststep ch gets mob
          walks = (ref = ch.walks) != null ? ref.slice(0) : void 0;
          if (walks == null) {
            return;
          }
          walk = random(walks);
          links = walk.vjson.links;
          options = [];
          for (m = 0, len = links.length; m < len; m++) {
            i = links[m];
            l = gta.walks[i];
            if (l == null) {
              continue;
            }
            c = gta.chunks[l.hash];
            if ((c == null) || (c != null ? c.firststep : void 0)) {
              options.push(l);
            }
          }
          if (!options.length) {
            return false;
          }
          link = random(options);
          if (link == null) {
            console.log('pedspawn: a link doesnt exist. this can happen'.red);
            return false;
          }
          tweens = Walk.prototype.gettweens(walk, link);
          tween = random(tweens);
          this.walk = walk;
          this.comefrom = link;
          this.props.x = tween.x;
          this.props.y = tween.y;
        } else {
          // refill via unobserved surrounding ch
          this.walk = gta.walks[this.props.to];
          this.comefrom = gta.walks[this.props.from];
          this.props.x = this.comefrom.props.x;
          this.props.y = this.comefrom.props.y;
        }
        this.traversed.push(this.comefrom);
        ((ref1 = gta.chunks[this.walk.hash]) != null ? ref1.pedsbound++ : void 0) || this.walk.pedsbound++;
        return true;
      }

      anim() {
        var motion;
        motion = this.body.GetLinearVelocity().Length();
        if (this.walking) {
          if (motion < .5) {
            this.walking = false;
          }
        } else {
          this.walking = motion > .8;
        }
        if (this.running) {
          if (motion < 2) {
            this.running = false;
          }
        } else {
          this.running = motion > 3;
        }
        if (this.running && this.states.w !== 2) {
          this.state('w', 2);
        } else if (this.walking && !this.running && this.states.w !== 1) {
          this.state('w', 1);
        } else if (!this.walking && !this.running && this.states.w !== 0) {
          this.state('w', 0);
        }
        return 1;
      }

      renode(force) {
        var a, d, i, len, m, range, ref, ref1, ref2, that, theta, w, ws, x, y;
        that = this;
        x = Math.abs(this.props.x - this.walk.props.x);
        y = Math.abs(this.props.y - this.walk.props.y);
        range = Math.hypot(x, y);
        if (force || range < 20 || this.panic && range < 38) {
          a = this.walk.vjson.links.slice(0);
          // a = a.filter (e) -> gta.walks[e] not in that.traversed
          i = Math.floor(Math.random() * a.length);
          // todo: really untested angle-biased preferencing
          // todo: test this decently or rewrite
          // todo: possibly preprocess the angles from any given node
          ws = [];
          for (m = 0, len = a.length; m < len; m++) {
            i = a[m];
            w = gta.walks[i];
            if (w == null) {
              continue;
            }
            theta = this.walk.angletoid[i];
            d = 180 - Math.abs(Math.abs(theta - this.bearing) - 180);
            ws.push({
              walk: w,
              angle: d
            });
          }
          ws.sort(function(a, b) {
            if (a.angle < b.angle) {
              return -1;
            } else {
              return 1;
            }
          });
          ws.sort(function(a, b) {
            var c, ref, ref1;
            c = (ref = a.walk, indexOf.call(that.traversed, ref) >= 0);
            d = (ref1 = b.walk, indexOf.call(that.traversed, ref1) >= 0);
            if (!c && d) {
              return -1;
            } else if (c === d) {
              return 0;
            } else if (c && !d) {
              return 1;
            }
          });
          this.comefrom = this.walk;
          this.walk = ((ref = ws[0]) != null ? ref.walk : void 0) || this.comefrom;
          this.traversed.push(this.comefrom);
          if (this.traversed.length > 30) {
            this.traversed.shift();
          }
          ((ref1 = gta.chunks[this.comefrom.hash]) != null ? ref1.pedsbound-- : void 0) || this.comefrom.pedsbound--;
          ((ref2 = gta.chunks[this.walk.hash]) != null ? ref2.pedsbound++ : void 0) || this.walk.pedsbound++;
          this.stray = -1;
        }
        // console.log "new node is #{a[i]}"
        return 0;
      }

      move() {
        var a, c, fifty, look, n, stray, t;
        if (this.walk == null) {
          return;
        }
        t = Date.now();
        a = this.body.GetAngle();
        if (!(this.pause < t)) {
          return;
        }
        this.renode();
        stray = this.stray > t && this.stray !== -1;
        if (!stray) {
          this.aim = this.pointatv(this.walk);
          this.stray = t + 500 + Math.random() * 750;
        }
        if (stray && this.aim !== -1) {
          c = Math.PI / 40;
          if (this.turn > 0) {
            n = a + c;
            if (n > this.aim && n <= this.aim + c * 2) {
              n = this.aim;
            }
          } else if (this.turn < 0) {
            n = a - c;
            if (n < this.aim && n >= this.aim - c * 2) {
              n = this.aim;
            }
          }
          if (n > Math.PI * 2) {
            n = n - (Math.PI * 2);
          } else if (n < 0) {
            n = (Math.PI * 2) - n;
          }
          if (n === this.aim) {
            this.aim = -1;
          }
          this.body.SetAngle(n);
        }
        a = this.body.GetAngle();
        fifty = Math.random() > .5;
        look = Math.random() * Math.PI / 3;
        this.aimto(fifty ? a + look : a - look);
        this.theta = a + Math.PI / 2;
        this.limp(true);
        return 0;
      }

      aimto(aim) { // slowly
        var a;
        a = this.body.GetAngle();
        this.aim = aim;
        this.turn = this.aim - a;
        if (this.turn > Math.PI) {
          // normalize
          this.turn = -(((Math.PI * 2) + a) - this.aim);
        }
        if (this.turn < -Math.PI) {
          this.turn = ((Math.PI * 2) - a) - this.aim;
        }
        return 0;
      }

      pointatv(v) {
        var r;
        this.theta = Math.atan2(this.props.y - v.props.y, this.props.x - v.props.x);
        r = this.theta - Math.PI / 2;
        if (r < 0) {
          r += Math.PI * 2;
        }
        this.body.SetAngle(r);
        return r;
      }

      limp(slow) {
        var s, theta, to, x, y;
        theta = this.theta;
        theta += Math.PI;
        s = slow ? this.haste : 0.8;
        x = s * Math.cos(theta);
        y = s * Math.sin(theta);
        to = new box2d.Common.Math.b2Vec2(x, y);
        theta = this.theta;
        this.body.ApplyImpulse(to, this.body.GetWorldCenter());
        return true;
      }

      hit(from, using, damage) {
        var floored, r;
        if (this.dead || this.kill) {
          return false;
        }
        if (from.type === 'Zombie') {
          this.health -= 34;
          this.panic = true;
          this.state('h', 0);
        } else if (from.type === 'Car') {
          floored = !(this.floored < Date.now() - 1500);
          if (!floored) {
            if (damage != null) {
              this.health -= damage;
            }
            if (this.kill) {
              this.state('r', 0); // run over
            } else {
              this.state('h', 0); // hit
              this.fall();
            }
          }
        } else if ((using != null ? using.type : void 0) === 'Gun') {
          this.panic = true;
          this.state('a', Math.floor(Math.random() * 4)); // alarmed
          this.health -= damage;
          this.state('h', 1); // hit
          
          // if Math.random() < .5
          r = Math.floor(Math.random() * 8);
          new Decal({
            decal: `b${r}`,
            x: this.props.x,
            y: this.props.y
          });
        } else if ((using != null ? using.type : void 0) === 'Melee') {
          this.panic = true;
          this.health -= damage;
          this.state('h', 1);
          r = Math.floor(Math.random() * 8);
          new Decal({
            decal: `b${r}`,
            x: this.props.x,
            y: this.props.y
          });
        }
        if (this.panic) {
          this.haste = 0.75;
        }
        this.checkup();
        return true;
      }

      checkup() {
        if (this.health <= 0) {
          this.kill = true;
        }
        return true;
      }

      die() {
        delete this.states.fall;
        delete this.states.up;
        delete this.states.s;
        this.dead = true;
        this.kill = false;
        this.died = Date.now();
        this.state('d', Math.floor(Math.random() * 10));
        if (this.body != null) {
          gta.world.DestroyBody(this.body);
        }
        this.body = null;
        if (Math.random() < .3) {
          gta.drop(this);
        }
        if (Math.random() < .6) {
          gta.loot(this);
        }
        return true;
      }

      fall() {
        var filter;
        delete this.states.s;
        this.floored = Date.now();
        // gta.world.DestroyBody @body
        // filter = new box2d.Dynamics.b2FilterData
        filter = this.fixture.GetFilterData();
        filter.categoryBits = gta.masks.none;
        filter.maskBits = gta.masks.none;
        this.fixture.SetFilterData(filter);
        this.state('fall', 0 + Math.floor(Math.random() * 3));
        return true;
      }

      getup() {
        var filter;
        delete this.states.fall;
        this.state('up', 1); // get up
        filter = this.fixture.GetFilterData();
        filter.categoryBits = gta.masks.organic;
        filter.maskBits = gta.masks.solid | gta.masks.organic;
        this.fixture.SetFilterData(filter);
        return true;
      }

    };

    Mob.prototype.ids = 0;

    Mob.prototype.pool = [];

    Mob.prototype.quotes = ["Nice weather ey?", "This world sucks"];

    return Mob;

  }).call(this);

  gta.Car = Car;

  gta.Visual = Visual;

  gta.account = require('./account');

  gta.missions = require('./missions');

  gta.start();

}).call(this);
